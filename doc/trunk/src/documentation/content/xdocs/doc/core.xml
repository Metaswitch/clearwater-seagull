<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">
<document>
  <header>
    <title>Seagull - Core</title>
  </header>
  <body>
    <figure alt="" src="images/seagull_logo.jpg" width="250"/>
    <section id="installation">
      <title>Installation</title>
      <section>
        <title>Platforms supported</title>
        <ul>
          <li>Linux: Seagull supports Linux. It has been successfully tested with 
        Debian, RedHat Advanced Server 2.1, RedHat Enterprise Linux 3.0, Suse 9.3 and Fedora core 3. It should be
        no problem for Seagull to work on other Linux platforms by compiling Seagull from the sources.</li>
          <li>HPUX 11i (PA-RISC and IA64): supported.</li>
          <li>HPUX 11.23 (PA-RISC and IA64): supported.</li>
          <li>Windows/cygwin: supported, only for IP-based protocols (for functional testing and limited load testing).</li>
        </ul>
        <note>
	  For TCAP support in Seagull, <a href="ext:hpoc">HP OpenCall SS7</a> is a pre-requisite, so an HP OpenCall SS7 compliant 
	  platform must be used.
        </note>
      </section>
      <section id="octave">
        <title>Installing Octave</title>
        <p>Seagull relies on "<a href="http://www.octave.org/">Octave</a>" to analyze detailed statistics and
        to provide plotting capability.</p>
        <note>Installing Octave is optional (Seagull runs properly without it). Statistics can also be computed from within Excel, 
        but there are many limitations (mainly file size) by doing so.</note>
        <p>There are 3 options to install Octave:</p>
        <ul>
          <li>If you installed your system using CD/DVDs: locate the Octave packages and install them.</li>
          <li>Download Octave for your distribution (using urpmi or apt tools).</li>
          <li>On a Windows PC, install "<a href="http://www.cygwin.com/">Cygwin</a>" 
	  and install Octave during Cygwin installation.</li>
        </ul>
      </section>
      <section>
        <title>Compiling Seagull from source code</title>
        <p>If the binary package is not available on your platform or if you want
        to modify Seagull source code to add you own features, you will need to
        compile Seagull from the source code.</p>
        <p>Decompress the source code tarball:</p>
        <source>gunzip seagull-x.y.z.tar.gz
tar -xvf seagull-x.y.z.tar</source>
        <p>This will create a directory called <code>seagull</code>.
        Go to this directory and edit "build.conf" file to add or remove sections you
        want to include during compilation time. To compile seagull:</p>
        <source>cd seagull
./build.ksh</source>
        <p>Executables are located in bin/. Copy them in /usr/local/bin and you should be ready to go.</p>
        <note>To compile Seagull from the source on CYGWIN, you need to install CYGWIN and the following packages: 
        shell/pdksh (Public Domain KSH), devel/gcc-g++, devel/make, devel/bison, devel/flex, vi</note>
      </section>
      <section>
        <title>Installing Seagull</title>
        <p>First, unzip and untar the Seagull archive file that corresponds to your platform:</p>
        <source>seagull-[tool version]-[OS]-[OS release version].tar.gz
        </source>
        <p>Then, use the package installer of your platform:</p>
        <ul>
          <li>HPUX 11i/11.23: 
            <source>swinstall -s /full_path_to_the_depot/seagull-core-[tool version]-[OS]-[OS release version]-[processor].depot</source>
            <source>swinstall -s /full_path_to_the_depot/seagull-[protocol]-[tool version]-[OS]-[OS release version]-[processor].depot</source>
          </li>
          <li>Linux RedHat-new and Fedora core 3 install: 
            <source>rpm -ivh seagull-core-[tool version]-[OS]-[OS release version]-[processor].rpm</source>
            <source>rpm -ivh seagull-[protocol]-[tool version]-[OS]-[OS release version]-[processor].rpm</source>
          </li>
          <li>Linux Debian: 
          <source>dpkg -i seagull-core-[tool version]-[OS]-[OS release version]-[processor].deb</source>
            <source>dpkg -i seagull-[protocol]-[tool version]-[OS]-[OS release version]-[processor].deb</source>
          </li>
          <li>Cygwin: user auto-extractible executable under Windows. 
          </li>
        </ul>
        <br></br>
        <p class="pageBreakBefore">Once the installation is done, the following directories are available:</p>
		<note>For versions older than 1.8.0.1 , please replace "opt" by "/usr/local/share"</note>
        <ul>
          <li>/opt/seagull/seagull/doc directory contains the documentation for all the protocols.</li>
          <li>/opt/seagull/[protocol]/doc directory contains protocol documentation.</li>
          <li>/opt/seagull/[protocol]/config directory contains the 
            XML configuration files, as described in the 
            <a href="#config">"Configuration files" section</a>, and the dictionaries, 
	    as described in the <a href="#config_dict">"Protocol dictionaries" section</a>.</li>
          <li>/opt/seagull/[protocol]/logs directory is empty. It is meant 
	  to contain execution log files.</li>
          <li>/opt/seagull/[protocol]/run directory contains examples of shell 
            scripts to run the client and server to execute your <a href="#config_scenario">scenarios</a>.</li>
          <li>/opt/seagull/[protocol]/scenario directory contains the example scenarios.</li>
        </ul>

        <note> The files present in those directories are given as simple examples. 
	It is highly recommended to not modify them, as <strong>they will be overwritten</strong> if you
  upgrade Seagull. Instead, <strong>create your own environment</strong> by copying /opt/seagull/[protocol]/ 
	directory tree to your home directory.</note>

        <p> The installation also creates the following files in the bin directory:</p>
        <source>/usr/local/bin/
     seagull
     computestat.ksh
     plotstat.ksh
     startoctave_plot.ksh
     startoctave_stat.ksh
     csvextract
     csvsplit
     [library-files].so</source>
        <p/>
        <p>/usr/local/bin directory contains the binaries of Seagull. Make 
            sure that this directory is in your user path by typing</p>
        <source>ocadmin@myhost:~$ type seagull
seagull is /usr/local/bin/seagull</source>
        <p/>
        <p>If Seagull can't be found, type:</p>
        <source>export PATH=$PATH:/usr/local/bin</source>
        <p/>
      </section>
      <section>
        <title>Uninstalling Seagull</title>
        <p>To remove Seagull from your system:</p>
        <ul>
          <li>On HPUX 11i/11.23, use swremove command.</li>
          <li>On Linux with rpm packager
            <ul>
            <li>find the list of packages to remove: <source>rpm -aq | grep seagull</source>
              </li>
              <li>Remove all the packages given by the previous command: <source>rpm -e package-name</source>
              </li>
            </ul>
          </li>
          <li>On cygwin, use the Windows uninstaller.</li>
        </ul>
      </section>

      <section>
        <title>Upgrading Seagull</title>
        <p>To upgrade from a previous version of Seagull:</p>
        <ul>
          <li>On HPUX 11i/11.23, follow uninstall procedure and then install procedure.</li>
          <li>On Linux with rpm packager: 
            <source>rpm -Uvh seagull-core-[tool version]-[OS]-[OS release version]-[processor].rpm</source>
            <source>rpm -Uvh seagull-[protocol]-[tool version]-[OS]-[OS release version]-[processor].rpm</source>
          </li>
          <li>On cygwin, follow the install procedure.</li>
        </ul>
      </section>
    </section>

    <section>
      <title>Using Seagull</title>
      <section>
        <title>Traffic profile</title>
        <p>The traffic profile is the evolution over time of the number of scenario attempts per second 
        (call rate). 
        By default, the traffic profile is constant, meaning that you set the rate at x, and it will remain x until you quit Seagull. 
        You can change the rate of scenario attempts interactively using the
        <a href="#control_keyboard">keyboard</a> or using the <a href="#control_remote">remote
        control interface</a>.</p>
        <p>A simple Perl script (<a href="http://gull.svn.sourceforge.net/viewvc/gull/seagull/trunk/src/tool-ctrl/ctrl.pl?view=markup">ctrl.pl</a>) is provided with Seagull to demonstrate
        the capabilities of the remote control interface as well as providing
        a way to create a repeatable traffic profile.</p>
        <p><a href="http://gull.svn.sourceforge.net/viewvc/gull/seagull/trunk/src/tool-ctrl/ctrl.pl?view=markup">ctrl.pl</a> takes two arguments: Seagull's remote control address 
        (as specified on the controlled Seagull through "-ctrl IP:PORT" command line option) and
        the traffic profile scenario to execute.</p>
        <p>A sample scenario (scenario.txt) is also provided:</p>
        <source># Comment 1
' Comment 2
SET RATE 20 CPS
WAIT 2S
DUMP
WAIT 2S
DUMP
SET RATE 40 CPS
WAIT 2S
DUMP
WAIT 2S
DUMP
RAMP 100 IN 30S
WAIT 10S
DUMP
WAIT 10S
DUMP
WAIT 10S
DUMP</source>
        <p>This scenario sets the rate to 20 scenario attempts per second, waits 2 seconds (this 
        is done at ctrl.pl level, not at Seagull level), dumps the counters, waits another 2
        seconds, dumps the counters again, sets the rate to 40 scenario attempts per second, and 
        so on. It creates the following traffic profile:</p>
        <p><img alt="Remote control" src="images/remote_ctrl_scen.png"/></p>
        <note>ctrl.pl is an example of the <a href="#control_remote">remote
        control interface</a>. If you modify ctrl.pl to add more features,
        we would appreciate that you post your findings back to 
        <a href="http://lists.sourceforge.net/lists/listinfo/gull-users">Seagull
        users mailing list</a>.</note>
      </section>
      <p class="pageBreakBefore"></p>
      <section>
        <title>Controlling Seagull</title>
        <p>Seagull can be controlled in three ways:</p>
        <ul><li><a href="#control_keyboard">Interactively</a>: using the keyboard
        attached to the terminal running Seagull</li>
        <li><a href="#control_remote">Remotely</a>: using the http server embedded in Seagull</li>
        <li><a href="#control_signal">Posix signals</a>: using Posix signals 
        to stop the traffic</li>
        </ul>
         <section id="control_keyboard">
          <title>Keyboard control</title>
          <p>Seagull can be controlled interactively using the keyboard.
          As there are many keys available to control Seagull, you can press "h"
          at any time to see the keys available and their function:</p>
          <source><![CDATA[
  |-----------------------------------------------------------------------------|
  | Key: Description                                                            |
  |-----------------------------------------------------------------------------|
  |+ : Increase call rate by call-rate-scale (default 1)                        |
  |- : Decrease call rate by call-rate-scale (default 1)                        |
  |c : Command mode (format : set var value)                                    |
  |    set call-rate      50 : call-rate become 50 c/s                          |
  |    set call-rate-scale 5 : use ± key to increase/decrease call-rate by 5    |
  |q : Tool exit (forced when pressed two times)                                |
  |p : Pause/Restart traffic                                                            |
  |b : Burst traffic (after pause)                                             |
  |f : Force init scenario (switch to traffic)                                  |
  |d : Reset cumulative counters for each stat set in config file               |
  |a : activate/deactivate: percentage in Response time screen                  |
  |1 : Traffic screen                                                           |
  |2 : Response time screen                                                     |
  |h : Help screen                                                              |
  |3 : Protocol octcap-itu screen(s)                                            |
  |A : Scenario traffic stats                                                   |
  |B : Scenario default 0 stats                                                 |
  |C : Scenario default 1 stats                                                 |
  |D : Scenario default 2 stats                                                 |
  |E : Scenario default 3 stats                                                 |
  |--- Select a key ----------------------- Next screen : Press the same key ---|]]></source>
          <p></p>
          <p>Notice that all the lines after "h : Help screen" are optional. 
      In our example they appear because the protocol statistics (see line "3 : Protocol octcap-itu screen(s)") 
      and the scenario statistics (lines from A to E) have been turned on.</p>
      <note>
      In case there is not enough space on the screen to display all the 
      optional lines, you have to press the h key again to display the end of 
      the help list.</note>
          <p>Description of the keyboard controls:</p>
          <p></p>
          <table id="ref_keys">
            <caption>Control keys</caption>
            <tr>
              <th>Key</th>
              <th>Short description</th>
              <th>Long description</th>
            </tr>
            <tr>
              <td>+</td>
              <td>Increase the call rate</td>
              <td>This key allows to increase the call rate from the call-rate-scale value. 
                The default value of the call-rate-scale is 1.<br/>
                Usable only in client mode. It has no effect in server mode.</td>
            </tr>
            <tr>
              <td>-</td>
              <td>Decrease the call rate</td>
              <td>This key allows to decrease the call rate from the call-rate-scale value. 
                The default value of the call-rate-scale is 1.<br/>
                Usable only in client mode. It has no effect in server mode.</td>
            </tr>
            <tr>
              <td>c</td>
              <td>Command</td>
              <td>This key allows to change any parameter in the configuration during traffic.<br/>
          For example:<br/>
          * press 'c', then 'set call-rate 10' to change the value of the call rate to 10.<br/>
          * press 'c', then 'set call-rate-scale 5' to change the value of the call-rate-scale to 5.<br/>
                Usable only in client mode. It has no effect in server mode.</td>
            </tr>
            <tr>
              <td>q</td>
              <td>Stop the traffic and quit the tool</td>
              <td>In <strong>server</strong> mode, Seagull does not accept any
                new incoming call. Once all ongoing calls are finished, the
                tool exits.<br/>
                In <strong>client</strong> mode, Seagull does not place any
                new call. Once all ongoing calls are finished, Seagull exits<br/>
                Pressing the q/ctrl-C key a second time forces Seagull to quit, even if
                all ongoing calls are not finished.</td>
            </tr>
            <tr>
              <td>p</td>
              <td>Pause/Restart the traffic</td>
              <td>In <strong>server</strong> mode, Seagull does not accept any
                new incoming call. Current calls continue.<br/>
                In <strong>client</strong> mode, Seagull does not place any
                new call. Ongoing calls are processed normally.<br/>
                By pressing p key a second time, seagull will restart traffic.<br/> 
                In <strong>server</strong> mode, Seagull accepts again new incoming call.<br/> 
                In <strong>client</strong> mode, Seagull smoothly restarts the traffic,
                 to go back to the required call rate.</td>
            </tr>
            <tr>
              <td>b</td>
              <td>Burst traffic (only available in <strong>client</strong> mode) </td>
              <td>Once the traffic is paused, restart traffic.<br/>
               In <strong>client</strong> mode, Seagull will try to 
              create all missed calls during the pause (for example, for a 5s pause with a 10c/s call rate, 
              seagull will try to start 5*10=500 calls when the "b" key is pressed).</td>
            </tr>
            <tr>
              <td>f</td>
              <td>Force without init</td>
              <td>This key allows to jump directly to the "traffic" section
                of a <a href="#config_scenario">scenario</a>, without waiting for the "init" section to be
                completed.</td>
            </tr>
            <tr>
              <td>d</td>
              <td>Reset cumulative counters for each statistics set in config file</td>
              <td>Reset the counters. This option is available only if log-stat, log-protocol, display-protocol 
          or display-scenario statistics options are set in the configuration file.</td>
            </tr>
            <tr>
              <td>1</td>
              <td>Display the main statistics screen</td>
              <td>Display the main screen with the general statistics. Press "1" 
          again to display the statistics per scenario.</td>
            </tr>
            <tr>
              <td>2</td>
              <td>Display the response time screen</td>
              <td>The second column gives the percentage of the calls for each 
          response time range, if the percentages are activated (see 'a' key). 
          This screen is relevant only if you set the proper options in the 
          configuration files and if you set the start and stop of the timer 
          in the scenario (see the <a href="#statistics">statistics</a> chapter).</td>
            </tr>
            <tr>
              <td>a</td>
              <td>Activate/deactivate the percentage computation</td>
              <td>This key activates or deactivates the computation of the percentages 
          of the response times screen, only if the log-stat is set in the 
          configuration file and if you set the start and stop of the timer 
          in the scenario (see the <a href="#statistics">statistics</a> chapter).</td>
            </tr>
            <tr>
              <td>h</td>
              <td>Show the help screen</td>
              <td>Press on h to show the help screen. <br/>
          If you see "Next screen: press the same key", press h again to see the second help screen.</td>
            </tr>
            <tr>
              <td>Numbers above or equal to 3</td>
              <td>Show protocol statistics screen</td>
              <td>If you asked for statistics at the protocol level, you can reach the corresponding screen by pressing the 
          corresponding number.<br/>
          3 is for the first protocol, 4 for the second one, 5 for the third one, and so on for all the protocols used.<br/>
          The possible values go from 3 to 0, so there are a maximum of 8 protocol statistics screens.</td>
            </tr>
            <tr>
              <td>Uppercase letters (starting with A)</td>
              <td>Show scenario section statistics</td>
              <td>If you asked for statistics at the scenario level, you can reach the corresponding screen by pressing the 
          corresponding letter.<br/>
          A is for the first section in the scenario, B for the second one, C for the third one, 
          and so on for all the sections used in your scenario.<br/>
          The number of scenario section statistics screens is limited to 26.</td>
            </tr>
          </table>
         </section>
         <section id="control_remote">
          <title>Remote control</title>
          <section><title>Description</title>
            <p>Seagull can be remotely controlled through a remote connection using 
            the HTML protocol and a dictionary that is provided at run time (-ctrldicopath command line option),
            the default being /opt/seagull/config/remote-ctrl.xml.(/usr/local/share/seagull/config/remote-ctrl.xml for versions before 1.8.0.1) <br/>
            This feature is activated with a run time option : -ctrl address:port 
            ("address:port" : the address and the port on which seagull listens for remote control commands)</p>
            <p>Using HTTP makes it very easy to remotely control Seagull, either directly from
            a browser or from higher level languages like Perl or Python.</p>
            <p>In particular, this allows to:</p>
            <ul>
              <li>Control a cluster of Seagull instances (hosted on one or several systems)</li>
              <li>Control the traffic profile over time (see the example with ctrl.pl
              Perl script)</li>
              <li>Automate benchmark test sessions</li>
              <li>Easily create a Graphical User Interface for Seagull control and monitoring (through http,
              AJAX, Eclipse plugin, ...)</li>
              <li>Create real time graphs with Seagull statistics (dump command)</li>
            </ul>
            <p>The following configurations are possible:<br></br>
            <img alt="Remote control" src="images/remote_ctrl.png"/></p>
          </section>
          <section><title>Control commands</title>
          <p>The following remote control commands are implemented:</p>
          <ul>
            <li><strong>Dump</strong>: to dump the statistics counters. This is done by sending
            an HTTP "<code>GET</code>" with URI: <source>http://x.y.z.t:p/seagull/counters/all</source></li>
            <li><strong>Set rate</strong>: to set the rate of scenario attempts per second. This is done by sending
            an HTTP "<code>PUT</code>" with URI: <source>http://x.y.z.t:p/seagull/command/rate?value=n</source></li>
            <li><strong>Ramp</strong>: to linearly increase or decrease the rate of scenario attempts per second,
            from the current value to a target value in a number of seconds.<br/> This is done by sending
            an HTTP "<code>PUT</code>" with URI: <source>http://x.y.z.t:p/seagull/command/ramp?value=n&amp;duration=d</source></li>
            <li><strong>Stop</strong>: to ask seagull to quit . This is done by sending
            an HTTP "<code>PUT</code>" with URI: <source>http://x.y.z.t:p/seagull/command/stop</source></li>
            <li><strong>Pause</strong>: to ask seagull to pause/restart the traffic. This is done by sending
            an HTTP "<code>PUT</code>" with URI: <source>http://x.y.z.t:p/seagull/command/pause</source></li>
            <li><strong>Burst</strong>: to ask seagull to make a burst when the traffic is paused seagull will try to create all 
            missed calls during the pause (only for client).<br/> This is done by sending an HTTP "<code>PUT</code>" with URI: <source>http://x.y.z.t:p/seagull/command/burst</source></li>
          </ul>
          </section>
         </section>
         <section id="control_signal">
            <title>Posix signal control</title>
            <p>It is also possible to stop the traffic using POSIX signals. This
            is especially useful when running Seagull in background mode 
            (<code>-bg</code> option, see the <a href="#cli_help">command line help</a>). </p>
            <p><code>kill -SIGUSR1 pid</code> has the same effect as the 'q' key. You
            can force the traffic to stop by issuing a second <code>kill -SIGUSR1 pid</code>.</p>
         </section>
        
      </section>
      <section>
        <title>Navigating through the screens</title>
        <p>Here is the screen that you see when you launch Seagull:</p>
        <source><![CDATA[|------------------------+---------------------------+-------------------------|
| Start/Current Time     |       2005-12-14 10:04:11 |     2005-12-14 10:06:53 |
|------------------------+---------------------------+-------------------------|
|    Counter Name        |      Periodic value       |     Cumulative value    |
|------------------------+---------------------------+-------------------------|
| Elapsed Time           | 00:00:01:008              | 00:02:41:596            |
| Call rate (/s)         |   75.397                  |   41.505                |
|------------------------+---------------------------+-------------------------|
| Incoming calls         |       76                  |     6707                |
| Outgoing calls         |        0                  |        0                |
| Msg Recv/s             |  149.802                  |   82.985                |
| Msg Sent/s             |  149.802                  |   82.979                |
| Unexpected msg         |        0                  |        0                |
| Current calls          |        3                  |    0.019                |
|------------------------+---------------------------+-------------------------|
| Successful calls       |       75                  |     6704                |
| Failed calls           |        0                  |        0                |
| Refused calls          |        0                  |        0                |
| Aborted calls          |        0                  |        0                |
| Timeout calls          |        0                  |        0                |
|------------------------+---------------------------+-------------------------|
| Last Info              | Incomming traffic                                   |
| Last Error             | No error                                            |
|--- Next screen : Press key 1 ----------------------- [h]: Display help ------|]]></source>
        <p></p>
        <note>In order to see the screens clearly, you are advised to launch 
	  Seagull in a terminal with at least the following geometry: 25 lines and 80 columns.</note>
        <p>At the bottom left, there is an invitation to press 1. Pressing the 1 key 
	  will get you to the following screen, that displays the number of successfull 
	  occurences of each types of scenarios (init, traffic, default and abort):</p>
        <p></p>
        <source><![CDATA[|------------------------+---------------------------+-------------------------|
| Success init calls     |        0                  |        0                |
| Success traffic calls  |       76                  |    13125                |
| Success default calls  |        0                  |        1                |
| Success abort calls    |        0                  |        0                |
|------------------------+---------------------------+-------------------------|
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|--- Next screen : Press key 1 ----------------------- [h]: Display help ------|]]></source>
        <p></p>
        <p>Press 1 again to come back to the first screen.</p>
        <note>All the screens in Seagull follow the same logic: if all the information 
	  cannot be displayed on one screen you'll have to press the same key once again 
	  to display the rest of the information.</note>
      </section>
    </section>
    <section>
      <title>Concepts and definitions</title>
      <section>
        <title>Scenario</title>
        <p>A <a href="#config_scenario">scenario</a> is what gets executed by Seagull. 
        Composed of multiple <a href="#Scenario+sections">sections</a>, each section is 
        a sequence of <a href="#ref_scenario_commands">commands</a>, described in XML. 
        Within a scenario section, &lt;send&gt; and &lt;receive&gt; commands are
        used to send and receive protocol messages.</p>
      </section>
      <section>
        <title>Session-Id</title>
        <p>The Session-Id is a generic concept in Seagull. Under classical usage,
        session-ids are not seen by the user. It can become handy to understand
        what a session-id is.</p>
        <p>A Session-Id maps to one or several protocol fields.
        How the mapping is done is indicated in the dictionary. For example, in Diameter, the session-id maps to
        Diameter's Session-Id avp. In H248, session-id maps to H.248's transaction-id.</p>
        <p>A session-id is valid for a channel. Thus, a scenario that makes use
        of multiple channels will have multiple session-ids.</p>
        <p>Let's take the example of a scenario which uses one channel.
        The scenario is the following:</p>
        <table>
        <tr>
        <td><source><![CDATA[  <send channel="trans-ip-v4">
    <action>
      <!-- For each new call, increment the session-ID counter -->
      <inc-counter name="HbH-counter"> </inc-counter>
      <inc-counter name="EtE-counter"> </inc-counter>
      <inc-counter name="session-counter"> </inc-counter>
      <set-value name="HbH-id" 
                 format="$(HbH-counter)"></set-value>
      <set-value name="EtE-id" 
                 format="$(EtE-counter)"></set-value>
      <set-value name="Session-Id" 
                 format=".;1096298391;$(session-counter)"></set-value>
    </action>
    <command name="SAR">
      <avp name="Session-Id" value="value_is_replaced"> </avp>
      <avp name="Vendor-Specific-Application-Id">
        <avp name="Vendor-Id" value="11"></avp>
        <avp name="Auth-Application-Id" value="167772151"></avp>
        <avp name="Acct-Application-Id" value="0"></avp>
      </avp>
      <avp name="Auth-Session-State" value="1"> </avp>
      <avp name="Origin-Host" value="seagull"> </avp>
      <avp name="Origin-Realm" value="ims.hpintelco.org"> </avp>
      <avp name="Destination-Realm" value="ims.hpintelco.org"> </avp>
      <avp name="Server-Name" value="seagull"> </avp>
      <avp name="Server-Assignment-Type" value="3"> </avp>
      <avp name="User-Data-Request-Type" value="0"> </avp>
      <avp name="Public-Identity" 
           value="sip:olivierj@ims.hpintelco.org"> </avp>
      <avp name="Destination-Host" value="hss.ims.hpintelco.org"> </avp>
    </command>
    <action>
      <start-timer></start-timer>
    </action>
  </send>
  
  <receive channel="trans-ip-v4">
    <action>
      <stop-timer></stop-timer>
    </action>
    <command name="SAA">
    </command>
  </receive>]]></source>
  </td>
  <td><source><![CDATA[When sending the message, Seagull 
initializes the session-id with the value of "Session-Id" AVP, 
as indicated in Diameter's dictionary

































When receiving a message, Seagull tries to find the 
session-id in the list of its known session-ids. If 
the parameter corresponding to the session-id (as 
indicated in the dictionary) is not found, then  
Seagull will look at parameters indicated by 
"out-of-session-id" parameters in the dictionary.
]]></source></td>
  </tr>
  </table>
        <p>In some cases, the session-id value is not in a unique field and may need to be found in other fields. To resolve this,
         multiple out-of-session-id fields can be defined in the dictionary. If a message is received with no session-id field or with
          an unknow value in the session-id field, then seagull looks for the first out-of-session-id field if defined. 
          If this first out-of-session-id field is not present or its value is unknown, seagull looks for the second out-of-session-id field 
          if defined and so on ...
          The most probable out-of-session-id field must be placed at the top of the list of out-of-session-id fields in the dictionary 
          to optimize the execution.</p> 
        <p>When a message is received and cannot be matched to
        a known session-id value (whether this value was related to the session-id field or one of the defined out-of-session-id fields), 
        then it is treated as a "new (incoming) call".</p>
      </section>
      <section>
        <title>Transport protocols and channels</title>
        <p>Seagull messages are sent/received using a transport protocol. Several transport protocols can be used: TCP, UDP or SCTP,
	 all three over IPv4 or IPv6. In addition, <a href="ext:hpoc">HP OpenCall SS7</a> can be used to provide TCAP over SS7 transport. 
   See <a href="octcap.html">TCAP</a> documentation for more details.</p>
   
        <p>You first have to define the transport to use. This is done in the <a href="#config_generic">generic configuration file</a> (see example below). 
	 Then you can open channels for the transport that you have defined. You can open one or several
	 channels. Each channel can be on the same or on different transports, and can use the same or
	 a different protocol.</p>
        <p><img src="images/channels.jpg" alt="Channels and protocols"/></p>
        <p>A channel makes the link between a transport and a protocol.</p>
        <note>A channel defined as server has to be opened as the FIRST channel. To open more than one channel as server, the <a href="#ref_correlation">"correlation feature"</a> must be used.</note>
        <p>Transport and channels are defined in the <a href="#transport_config">generic configuration file</a>
        </p>
        <p>Here are some examples:</p>
        <ul>
          <li>Example using TCP over IPv4:
        <source><![CDATA[
  <define entity="transport"
    name="trans-ip-v4"
    file="libtrans_ip.so"
    create_function="create_cipio_instance"
    delete_function="delete_cipio_instance"
    init-args="type=tcp">
  </define>

  <define entity="channel"
    name="channel-ip-1"
    protocol="Protocol"
    transport="trans-ip-v4"
    open-args="mode=client;dest=192.168.0.13:3868">
  </define>
]]></source>
          </li>
          <li>Example using TCP over IPv6:
        <source><![CDATA[
  <define entity="transport"
    name="trans-ip-v6"
    file="libtrans_ip.so"
    create_function="create_cipio_instance"
    delete_function="delete_cipio_instance"
    init-args="type=tcp">
  </define>

  <define entity="channel"
    name="channel-ip-1"
    protocol="Protocol"
    transport="trans-ip-v6"
    open-args="mode=client;dest=[fec0::5:20f:20ff:fefe:ea51]:3868">
  </define>]]></source>
          </li>
          <li>Example using TLS over IPv4:
        <source><![CDATA[
  <define entity="transport"
    name="trans-ip-tls"
    file="libtrans_iptls.so"
    create_function="create_ciptlsio_instance"
    delete_function="delete_ciptlsio_instance"
    init-args="method=SSLv23;cert_chain_file=xxx;private_key_file=yyy;passwd=zzz">
  </define>

  <define entity="channel"
    name="channel-tls"
    protocol="Protocol"
    transport="trans-ip-tls"
    open-args="mode=client;dest=192.168.0.10:3868">
  </define>]]></source>
          </li>
          <li>Example using SCTP over TCP:
        <source><![CDATA[
  <define entity="transport"
    name="trans_sctp"
    file="libtrans_extsctp.so"
    create_function="create_cipsctpio_instance"
    delete_function="delete_cipsctpio_instance"
    init-args="type=tcp">
  </define>

  <define entity="channel"
    name="channel-sctp"
    protocol="Protocol"
    transport="trans-sctp"
    open-args="mode=client;dest=127.0.0.1:7000">
  </define>
]]></source>
          </li>
        </ul>
        <p/>
        <p>For more details, see "<a href="#transport_config">Transport Configuration</a>".</p>
      </section>
      <section>
        <title>SCTP transport</title>
        <p>Seagull supports SCTP transport with SCTP library in version 1.5 and SCTP Socket api
        library in version 1.9.0 (refer to <a href="http://www.sctp.de/sctp-download.html">www.sctp.de</a>).
        <warning>Seagull only supports SCTP over TCP transport on linux platform. </warning>
        <warning>"Root" privileges are something needed to execute Seagull with SCTP transport. </warning>
        </p>
      </section>  
      <section>
        <title>Multi-channels</title>
        <p>Seagull supports several channels in one single scenario. This means that you can create
	a scenario that for example sends a message on channel 1, receives the answer on channel 1, then sends a message
	on channel 2 and receives the answer on channel 2.</p>
        <p></p>
        <warning>Following the session-id principles, multi-channel
        scenarios can become complex. For example, to define a scenario where the
        first command is a message sent on channel-1 and the
        second command is a message received on channel-2, 
        the <a href="#ref_correlation">"correlation feature"</a> must be used.</warning>
      </section>
      <section id="traffic_models">
      <title>Traffic Models</title>
      <p>Seagull generates traffic using different model types:</p>
      <li><strong>Uniform</strong> : for each interval, seagull tries to reach the expected call rate, 
        regardless of what happened during the last interval. With this value, the max-receive and 
        max-send options are automatically set. It is not recommended for a low call rate. To reach a high 
        call rate, it is necessary to increase the call-rate slowly (with the keyboard control or the remote control) 
        to avoid a burst phenomenon.<br/>
        Example of traffic generated for:<br/>
        <u>1 call/s </u><br/>
        <img src="images/uniform_1cs.jpg" alt="Uniform 1 c/s"/>
        <br/>
        <u>10 calls/s</u> <br/>
        <img src="images/uniform_10cs.jpg" alt="Uniform 10 c/s"/>
        <br/>
        <u>100 calls/s</u> <br/>
        <img src="images/uniform_100cs.jpg" alt="Uniform 100 c/s"/>
      </li>
      <li><strong>Best-effort</strong>: seagull tries to maintain the expected average 
        call rate by adjusting the instantaneous call rate using the rates reached during the previous 
        intervals<br/>
        Example of traffic generated for:<br/>
        <u>1 call/s </u><br/>
        <img src="images/best_1cs.jpg" alt="Best 1 c/s"/>
        <br/>
        <u>10 calls/s</u> <br/>
        <img src="images/best_10cs.jpg" alt="Best 10 c/s"/>
        <br/>
        <u>100 calls/s</u> <br/>
        <img src="images/best_100cs.jpg" alt="Best 100 c/s"/>
      </li>
      <li><strong>Poisson</strong>: the real call rate varies around the expected call rate according
         to the Poisson distribution<br/>
         Example of traffic generated for:<br/>
        <u>1 call/s </u><br/>
        <img src="images/poisson_1cs.jpg" alt="Poisson 1 c/s"/>
        <br/>
        <u>10 calls/s</u> <br/>
        <img src="images/poisson_10cs.jpg" alt="Poisson 10 c/s"/>
        <br/>
        <u>100 calls/s</u> <br/>
        <img src="images/poisson_100cs.jpg" alt="Poisson 100 c/s"/>
        <br/>
      </li>
         
      <p>This parameter is set in the configuration file of the client.</p>
      <p>For more details, see "<a href="#generic_config">Generic configuration</a>".</p>
      </section>
    </section>
    <section id="config_scenario">
      <title>Seagull scenario</title>
      <section>
        <title>Scenario sections</title>
        <p>A scenario describes the messages exchanged
          during traffic and their parameters.  It contains several sections:</p>
        <source><![CDATA[  <scenario>
    <counter>
    </counter>
    
    <correlation>
    </correlation>

    <init>
    </init>
    
    <default>
    </default>
  
    <abort>
    </abort>
  
    <traffic>
    </traffic>
  </scenario>]]></source>
        <section id="scen_counter">
          <title>Counter section</title>
          <p>The <strong>counter</strong> section contains a list of counters that 
          are available during the traffic. This is useful, for example, to handle session-ids (the name
          varies depending on the protocol) which are used to identify calls in Seagull.</p>
          <p>For example, the following code declares 3 counters: HbH-counter (initial value: 1000), 
          EtE-counter (initial value: 2000) and session-counter (initial value: 0).</p>
          <source><![CDATA[<counter>
  <counterdef name="HbH-counter" init="1000"> </counterdef>
  <counterdef name="EtE-counter" init="2000"> </counterdef>
  <counterdef name="session-counter" init="0"> </counterdef>
</counter>]]></source>
          <p>Those counters can then be used in the scenario using the <a href="#action_inc-counter">inc-counter</a> 
          and <a href="#action_set-value">set-value</a>
          scenario actions (see <a href="#ref_actions">scenario actions section</a>).</p>
        </section>
        <section id="scen_corr">
          <title>Correlation section</title>
          <p>The <strong>correlation</strong> section is used to define rules to associate several 
          session-ids to a single call. It supports scenario that use one or multiple channels.</p>
          <p>Refer to the <a href="#ref_correlation">"Correlation" section</a> for further details.</p>
        </section>        
        <section id="scen_init">
          <title>Init section</title>
          <p>The <strong>init</strong> section is executed once, at the time the connection is setup
            (before any traffic). This can be in a server type or in a client type scenario.</p>
          <p>This section can be used as a pre-amble to the traffic (like CER/CEA exchange
          for Diameter protocol).</p>
          <p>The list of scenario commands that can be included in this section is 
            described in the <a href="#ref_scenario_commands">scenario command section</a>.</p>
        </section>
        <section id="scen_default">
          <title>Default section</title>
          <p>The <strong>default</strong> section is executed when an unexpected message (not listed 
            in the traffic section) is received. This can be a server type or a client type scenario.</p>
          <p>There can be as many default sections as needed. Seagull tries to match the
            received message against the first message of the default section.</p>
          <p>The default section is generally used to create defensive scenarios, so that
            Seagull can react when stress situations from the system under test 
            are encountered.</p>
          <p>By default, Seagull counts calls using a "default" scenario section as successful calls. You can
          choose to count them as failed calls or simply ignore them. To do so, you need to add a 
          "<code>behaviour</code>" attribute to the
          default section. Values of the behaviour attribute can be either "ignore" or "failed". Example:</p>
          <source><![CDATA[<default behaviour="ignore">
  <receive channel="channel-1">
    <primitive name="SCCP_USER_STATUS">
    </primitive>
  </receive>
</default>]]></source>
          <p></p>
          <p>The list of scenario commands that can be included in this section is 
            described in the <a href="#ref_scenario_commands">scenario command section</a>.</p>
        </section>
        <section id="scen_abort">
          <title>Abort section</title>
          <p>The <strong>abort</strong> section is executed to finish a call when something wrong
            happened. The first command has to be a &lt;send&gt;</p>
          <p>The list of scenario commands that can be included in this section is 
            described in the <a href="#ref_scenario_commands">scenario command section</a>.</p>
        </section>
        <section id="scen_traffic">
          <title>Traffic section</title>
          <p>The <strong>traffic</strong> section is the main traffic. This can be in a server type 
	    or in a client type scenario.</p>
          <p>The list of scenario commands that can be included in this section is 
            described in the <a href="#ref_scenario_commands">scenario command section</a>.</p>
        <warning>When "init" and "traffic" are both present, Seagull only supports same nature sections:<br/>
        if the "init" section starts with a "send" command, the "traffic" section must start with a "send" command,<br/>
        if the "init" section starts with a "receive" command, the "traffic" section must start with a "receive" command. </warning>
        </section>
      </section>
      <section id="scen_cmds">
        <title>Actions in scenarios</title>
        <p>The &lt;send&gt; and &lt;receive&gt; scenario commands can include &lt;action&gt; and
              &lt;message&gt; sections.</p>
        <note>"message" depends on the protocol. This is "command" for Diameter, "primitive" for TCAP, ...</note>
        <p>The &lt;action&gt; section can be placed before and/or after the &lt;message&gt; section.</p>
        <p>Actions placed before the message (called 
              "<strong>pre-actions</strong>") are executed just before the message is actually
              sent or received. Actions placed after the message (called 
              "<strong>post-actions</strong>") are executed just after the
              message is sent or received. </p>
        <p>There are many actions available. To name a few, you can increment <a href="#call_variables">call variables</a>, 
              start or stop a timer, store a parameter from an incoming message or re-inject it in an outgoing message,
              do <a href="#control">controls</a> on the message or inject values from an external data file. Click 
              <a href="#ref_actions">there to see the complete list</a>.</p>
        <source><![CDATA[<send>
  <action>    <!-- Pre-action  -->
  </action>
  <message>   <!-- Message     -->
  </message>
  <action>    <!-- Post-action -->
  </action>
</send>]]>
              </source>
        <p>Actions that can be placed <strong>before</strong> a message are actions
              to increment a counter before sending the message. Example:</p>
        <source><![CDATA[   <send channel="channel-1">
     <action>
        <inc-counter name="session-counter"></inc-counter>
        <set-value name="user-id-1" format="$(session-counter)"></set-value>
     </action>
     <message name="FOO_BAR">
     </message>
   </send>
      ]]></source>
        <p>Actions that can be placed <strong>after</strong> a message are actions to store
              parameter values after the message has been received. Example:</p>
        <source><![CDATA[   <receive channel="channel-1">
     <message name="FOO_BAR">
     </message>
     <action>
       <store name="SESSION-ID" entity="user-id-1"></store> 
     </action>
   </receive>]]></source>
        <p>The list of <a href="#ref_actions">possible actions</a> is available 
              in the reference section. All actions can be pre- or post-actions.</p>
      </section>
      <section id="call_variables">
        <title>Call variables</title>
        <p>In order to have dynamical scenarios, Seagull has "call variables".
          Those variables are local to each call (each instance of the scenario) 
          except for the counters which are global to the seagull instance.</p>
        <p>Here is what is possible to do with call variables:</p>
        <ul>
          <li>Set the value of a protocol entity by using the <a href="#action_set-value">set-value</a> action.</li>
          <li>Increment a call variable within a call by using the <a href="#action_inc-var">inc-var</a> action.</li>
          <li>Retrieve the value of a protocol entity in a call variable by using the <a href="#action_store">store</a> action.</li>
          <li>Put the value of a call variable in a protocol entity by using the <a href="#action_restore">restore</a> action. 
          In particular, this is how Diameter Hop-by-hop Id and End-To-End Id can be handled.</li>
        </ul>
      </section>
      <section id="counters">
        <title>Counters</title>
        <p>In order to have unique identifier for a seagull instance, Seagull has "counters".
          Those counters are as global variables to the seagull instance.</p>
        <p>Here is what is possible to do with counters:</p>
        <ul>
          <li>Set the value of a protocol entity by using the <a href="#action_set-value">set-value</a> action.</li>
          <li>Increment a call counter by using the <a href="#action_inc-counter">inc-counter</a> action.</li>
          <li>Put the value of a call variable in a protocol entity by using the <a href="#action_restore">restore</a> action.</li>
        </ul>
      </section>
      <section id="store_restore">
        <title>Store and restore of protocol parameters</title>
        <p>Some of the most useful actions are the store and restore actions.
        In the following example, we will explain how to use the store
        and restore actions for 3 protocols: SIP (text), Diameter (binary)
        and TCAP (api).</p>
        <note>A store action is generally executed as a post-action, while
        a restore action is generally executed as a pre-action.</note>
        <ul><li><u>SIP (text)</u>. There are several ways to use
        the store action for a text protocol:
        <ul><li><strong>You want the entire value of a protocol field</strong>: 
        in this case, the store action can simply be used as:
        <source><![CDATA[<store name="MYVAR" entity="via"></store>]]></source>
        The variable "MYVAR" contains the value of the Via header field.<br/>Similarly, 
        the Via header value can be restored using:
        <source><![CDATA[<restore name="MYVAR" entity="via"></restore>]]></source>
        which will put the value of "MYVAR" in the Via header field (as declared
        in the dictionary).</li>
        <li><strong>You want part of the value of a protocol field, using a regular expression</strong>:
        in this case, the store action can include a regular expression:
        <source><![CDATA[<store name="MYVAR" entity="via">
  <regexp name="viabranch"
    expr="[Vv][Ii][Aa][    ]*:[  ]SIP/2.0/(UDP|TCP) ([A-Za-z0-9.:_-]*)(;branch=(.*))*"
    nbexpr="5"
    subexpr="4">
  </regexp></store>]]></source>
        The variable "MYVAR" contains the value of the branch field in the SIP via header.<br/>Similarly, 
        the Via branch value can be restored using:
        <source><![CDATA[<restore name="MYVAR" entity="via-branch"></restore>]]></source>
        which will put the value of "MYVAR" in the via-branch header field (it will
        need to be declared in the dictionary).</li>
        </ul>
        </li>
        <li><u>Diameter (binary)</u>: in a binary protocol, store and restore
        actions can be done using directly the fields declared in the XML dictionary, 
        like this:
        <source><![CDATA[<store name="MYVAR" entity="via"></store>]]></source>
        and then:
        <source><![CDATA[<restore name="MYVAR" entity="via"></restore>]]></source>
        <note>store and restore actions on Diameter Grouped AVPs are supported by version 1.8.0 onwards</note>
        </li>
        <li><u>OCTCAP (API)</u>: to store and restore
        fields, you must identify which field you want to store and restore like this:
        <source><![CDATA[<store name="MYVAR" entity="TC_INVOKE" sub-entity="operation-data"
   instance="InitialDP-data" begin="5" end="10"></store>]]></source>
        Note that begin and end attributes are used to extract part of the operation-data 
        (like correlation-id or called party number).
        Same for the restore:
        <source><![CDATA[<restore name="MYVAR" entity="TC_CONTINUE" sub-entity="operation-data"
   instance="ApplyCharging-data" begin="9" end="14"></restore>]]></source>
        This will set the value of the operation-data field (starting octet 9, ending octet 14) 
        in the TC_CONTINUE named "ApplyCharging-data"
        with the content of "MYVAR".
        </li>
        </ul>
        <warning>As init section and traffic section are hold as different calls, do not store a 
          value in the init section to restore it in the traffic section.</warning>
        <warning>The "store" action on an unavailable field will make the call to be marked as failed. </warning> 
      </section>
    </section>
    <section id="control">
      <title>Message and parameters control</title>
      <p>Even if Seagull is aimed at traffic, load and stress testing, it is 
        possible to check messages and parameters during traffic.</p>
      <note>The more controls you put, the less traffic Seagull can handle.</note>
      <p>Several levels of control are available and described
        in the following sections.</p>
      <section>
        <title>Enabling and disabling controls</title>
        <p>Controls can be enabled at two different levels:</p>
        <ul>
          <li>Globally, in the <a href="#config_generic">generic configuration file</a>.</li>
          <li>Globally, using <code><![CDATA[-msgcheck]]></code> parameter in the <a href="#cli_help">command line</a>.</li>
          <li>Per message, in the <a href="#config_scenario">scenario</a> file, in a <a href="#scen_cmds">post-action</a> section of a message:
            <source><![CDATA[<check-presence name="[FIELD_NAME]" behaviour="error"></check-presence>]]></source>
          </li>
        </ul>
      </section>
      <section>
        <title>Behaviour when a control fails</title>
        <p>You can specify the behaviour of Seagull for the different controls. 
	  This behaviour can be defined at the control level (see examples in the following chapters) or globally. 
	  The rest of this section presents the ways to define a global behaviour.
	  </p>
        <p>Define in the XML configuration file "Warning" as the global behaviour when a control fails:</p>
        <source><![CDATA[<define entity="traffic-param"
  name="msg-check-behaviour"
  value="W">
</define>]]></source>
        <p>Define in the XML configuration file "Error and abort" as the global behaviour when a control fails:</p>
        <source><![CDATA[<define entity="traffic-param"
  name="msg-check-behaviour"
  value="E">
</define>]]></source>
        <p>The global behaviour is applied for all controls that do not have their behaviour attribute defined in the scenario.
	  </p>

        <p>If the control is OK, the scenario goes on. If the control fails,
        the behaviour is:</p>
        <ul>
          <li>Log a <strong>warning</strong> and continue the call</li>
          <li>Log an <strong>error</strong> and abort the call</li>
        </ul>
      </section>
      <p class="pageBreakBefore"></p>
      <section id="check_presence">
        <title>Presence check</title>
        <p>The goal of this control is to check for the presence of parameters as described
            in the scenario. There are two types of presence check:</p>
        <ul>
          <li>
            <strong>Presence</strong>: Seagull checks that <strong>at least</strong> the parameters
                listed in the scenario are present in the received message. If additional
                parameters are present, the call is still considered OK. But if any expected parameter
                is missing, then the control fails.</li>
          <li>
            <strong>Additional</strong>: Seagull checks that <strong>all and only</strong> the parameters
                listed in the scenario are present in the received message. If additional 
                parameters are present, the call is considered failed. If any expected
                parameter is missing, then the specified behaviour is applied.</li>
        </ul>
        <p>The type of presence check is set in the <a href="#config_generic">generic configuration file</a>:</p>
        <ul>
          <li>To enable "Presence" check in the generic configuration file:
              <source><![CDATA[<define entity="traffic-param"
        name="msg-check-level"
        value="P">
      </define>]]></source>
          </li>
          <li>To enable "Additional" check in the generic configuration file:
              <source><![CDATA[<define entity="traffic-param"
        name="msg-check-level"
        value="A">
      </define>]]></source>
          </li>
        </ul>
        <p>Example for Diameter protocol:</p>
        <source><![CDATA[
<receive channel="channel-1">
  <command name="SAA">
  </command>
  <action>
    <check-presence name="name_of_avp_to_check" behaviour="error"></check-presence>
  </action>
</receive>
]]></source>
        <note>"command" is specific to Diameter. It should be replaced by the appropriate keyword
          depending on the protocol</note>
        <warning>The check <strong>must</strong> be defined in the <a href="#scen_cmds">post-action</a> section
          of the <![CDATA[<receive>]]> scenario command.</warning>
      </section>
      <section id="check_value">
        <title>Parameter value check</title>
	<note>"branch_on" feature is only present for seagull version 1.8.1, onwards</note>
        <p>Seagull can also perform controls on the value of the fields (of the header or 
        the body) of a message.</p>
        <p>Those controls are defined in the scenarios.</p>
        <note>In general, the control is done against the value indicated in the scenario.</note>
        <p> Examples (as part of the receive section of a message in the scenario):</p>
        <ul>

          <li>Check the value of the field specified with "name" in the received message.
	  <p></p>
            <source><![CDATA[<!-- Diameter example-->
<check-value name="Vendor-Specific-Application-Id" behaviour="error">
</check-value>]]>
	  </source>
          </li>
          <li>Check the value of the sub-entity of the field specified with "name=" and with "instance=" 
          in the received message 
	  <p></p>
            <source><![CDATA[<!-- TCAP example-->
<check-value name="TC_INVOKE" sub-entity="operation-code" behaviour="error"
      instance="Client-1-data">
</check-value>]]>
	  </source>
          </li>
          <li>Check the value of a header field: you check that the field (specified with 
	  "name") in the header of the message has the expected value, which in this specific case of TCAP  
	  is defined in the configuration file.
	  <p></p>
            <source><![CDATA[<!-- TCAP example-->
<check-value name="d-address-pc" behaviour="error">
</check-value>]]>
	  </source>
            <p></p>
          </li>
        </ul>
	<p> Examples for check-value usage for branching:</p>
	<ul>

          <li>For branching, only parameters required are branch_on, look_ahead or look_back; behaviour is also set as error,
	  to maintain check-value's structure. "name" is not needed for branching,so not maintained as mandatory param for check-value.
	  For a jump in the scenario,check-value has to be present as a post action, specifying that in case of an unexpected message received, what should the scenario do.
	  In case the unexpected message matches the value for branch_on, it would either jump as many sections in scenario,ahead or backwards, as specified by look_ahead,
	  or look_back params in the traffic section. Apart from handling unexpected messages, this feature can be used to handle optional messages.
	  
	  This feature has limitations however, intended to be fixed in later releases.
	  One limitation being that, for the unexpected message received,no other actions apart from jump, will be executed.
	  An example involving sip protocol is below:		  
	  <p></p>
            <source><![CDATA[<!-- SIP example-->
<check-value behaviour="error" branch_on="100" look_ahead="2">
</check-value>]]>
	  </source>
	  <p></p>
          </li>
	  </u1>
	  <figure alt="An Example for scenario jump" src="images/branch.PNG" width="967"/>
      </section>
      <section id="check_order">
        <title>Message order check</title>
        <note>Message order check is implemented for TCAP protocol only.</note>
        <p>Seagull can also perform controls on the order in which the parameters are received in the messages. 
	  </p>
        <p>Those controls are defined in the scenarios.</p>
        <p>In the case of TCAP, the order of reception of the components (eg TC_INVOKE) inside primitives (eg TC_BEGIN) can be checked.</p>
        <p>Example: check that the parameter specified with "name" is received in second position.</p>
        <source><![CDATA[<!-- TCAP example-->
<check-order name="TC_INVOKE" behaviour="error" position="1">
</check-order>]]>
          </source>
        <note> The position starts at zero, so position=1 checks for the second position.</note>
        <note>If the specified position is greater than the number of 
	  received components, then an error is logged (as defined with "behaviour") and the call is aborted.</note>
      </section>

    </section>

    <section>
      <title>External data management</title>
      <section>
        <title>Description</title>
        <p>Seagull allows to change the content of the messages before sending them, according
        to an external data file (CSV format). 
        For each new scenario that Seagull executes, a new line is read from the external data file. 
        This line contains the values of one or several fields which  
        are used to change the content of a sent message on a per scenario basis.
        Lines can be read in sequence or randomly. </p>
        <p>For example, this feature allows to provision a list of users or subscribers that
        are used during Seagull's traffic.</p>
        <p>To use this feature, you need to specify "external-data-file" (file to
        read from) and "external-data-select" (how to read the file) parameters in the configuration file:</p>
        <source><![CDATA[  <define entity="traffic-param"
          name="external-data-file"
          value="FULL_PATH/EXTERNAL_FILE.csv">
  </define>

  <define entity="traffic-param"
          name="external-data-select"
          value="sequential">
  </define>]]></source>
        <p/>
        <p>The value of the "external-data-select" parameter can be <strong>"random"</strong> 
      or <strong>"sequential"</strong>. 
      In the first case, the specific content for a message is taken randomly from the external data file.
      In the second case, the specific content for a message is taken in a sequential order (the first line of the external data file for the first call, 
the second line for the second call, etc.).</p>
        <p>Here is an example of external data file: </p>
        <source><![CDATA[ "string";"string";"number";
# FIELD 0        FIELD 1       FIELD 2    
"0472826017" ;  "0x214365870921" ; "10" ;
"0472826027" ;  "0x214365870931" ; "12" ;
"0472826037" ;  "0x214365870941" ; "14" ;
"0472826047" ;  "0x214365870951" ; "16" ;
"0472826057" ;  "0x214365870961" ; "18" ;
"0472826067" ;  "0x214365870971" ; "20" ;
"0472826077" ;  "0x214365870981" ; "22" ;
]]></source>
        <p/>
        <p> Notice that the comments can be prefixed by # or // and 
      that string values can be in ASCII (for example: "10" translates into 0x3130) or 
      hexadecimal (for example: "0xA2") format.</p>
        <p> The first line with characters and that does start by the comment sign is the line 
      that defines the data types contained in the file. This line is 
      <strong>mandatory</strong>. The types must belong to the basic types of Seagull: 
      string, number, signed, number64 or signed64.</p>
        <p> On each line of data, you can access a field (column) with its index: the first data on the line is 
      field(0), the second one is field(1), and so on.</p>
        <p>This index is used in the scenario to define which data field in the external file is used to fill the specified field ("entity") 
      of the message to be sent.</p>
        <p>The external data can also be used to fill a defined part of a field. In order to do so, 
      the position in the buffer that represents the field to fill where to start to inject the data ("begin" parameter)
      and the position where to stop to inject the data ("end" parameter) need to be defined.
      When using the "begin" and "end" parameters, be careful that the count starts at zero for the first octet.
      Here is an example from a client scenario:</p>
        <source><![CDATA[<restore-from-external field="1" entity="FIELD_NAME"
       begin="1" end="3">
       </restore-from-external>]]></source>
        <p>In this example, the data (2 octets) is injected starting at the second octet (0 is 
      the first octet, so 1 is the second octet). Two bytes of data are injected at the second octet and at the third octet.</p>
        <p>The field FIELD_NAME must exist in the message to be sent, as defined in the dictionary. 
      Its value in the current message before restore-from-external is executed is changed to the data of the second column
      (second because field="1").</p>
        <note>When the specified size (difference between "begin" and "end" values) is larger than the injected data, 
      then the data is injected in its full length from the "begin" position and a warning is logged.</note>
        <note>When the destination buffer is too short to reach the "begin" position (e.g. buffer with 2 numbers and "begin=5"), 
      zeros are added to the destination buffer so it reaches a size big enough to enable the injection of the buffer at 
      the "begin" position (example: insert "11" at position 5 in buffer "22", the buffer becames "2200011"). A warning is logged.</note>
      </section>
      <section>
        <title>Example</title>
        <p/>
        <figure alt="Example of external data injection" src="images/external_data.png" width="967"/>
        <p>In this example, TCAP's operation-data with an initial value of "0x3016a00e820c48656c6c6f2c20776f726c64810100820100"
        will be altered from octet 5 to octet 11 (first octet is 0) so that the values will be:</p>
        <ul>
        <li>0x3016a00e82<strong>214365870921</strong>2c20776f726c64810100820100 for 1st scenario execution</li>
        <li>0x3016a00e82<strong>214365870931</strong>2c20776f726c64810100820100 for 2nd scenario execution</li>
        <li>0x3016a00e82<strong>214365870941</strong>2c20776f726c64810100820100 for 3rd scenario execution</li>
        <li>0x3016a00e82<strong>214365870951</strong>2c20776f726c64810100820100 for 4th scenario execution</li>
        <li>...</li></ul>
      </section>
    </section>
    <p class="pageBreakBefore"></p>
    <section id="Authentication">
    <title>Authentication</title>
    <p>Authentication has been introduced in Seagull. Digest/MD5 and Digest/AKA are both supported. <br/>
    To use it, an "external method" must be defined in the dictionary (refer to <a href="#external-method">"external-method"</a>) 
    and the method must be defined in a set-value action for the field to be encoded (refer to <a href="#action_set-value">"set-value"</a>).
    <br/>See <a href="sip.html#sip_authentication">SIP authentication</a> or <a href="radius.html#radius_authentication">Radius authentication</a> 
for further details based on examples.
    </p>
    </section>
    <p class="pageBreakBefore"></p>
    <section id="statistics">
      <title>Statistics</title>
      <p>Statistics is an important part of a performance test tool. Seagull
        provides three different sets of statistics: <a href="#stats_global">global 
        statistics</a>, <a href="#stats_responsetime">response time</a> statistics, 
	<a href="#stats_protocol">protocol</a> and <a href="#stats_scenario">scenario</a>
	statistics.</p>
      <p>Raw statistics data is saved using 
        <a href="http://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> file format. 
        This makes it easy to import the file in specialized applications, like
        <a href="http://www.octave.org">Octave</a> or 
        <a href="http://en.wikipedia.org/wiki/Microsoft_Excel">Microsoft Excel</a>
        to analyse the results and create graphs out of the results.</p>
      <p>A new line of statistics is dumped for every statistics period, allowing
        to follow the statistics over time.</p>
      <section id="stats_global">
        <title>Global statistics</title>
        <p>Global statistics are used to get global informations on the traffic. 
          See <a href="#traffic_log_stat">config 
          file reference</a> / log-stat-* parameters to activate those statistics.</p>
        <p>Those statistics have many counters. Here is the list. Counters can have a (P) or (C) appended
          to their name, meaning that the values are (C)umulative (from the beginning
          of the traffic) or (P)eriodic (for the statistics period, as specified by the
          <a href="#traffic_log_stat">log-stat-period</a> traffic-param).</p>
        <ul>
          <li>
            <strong>StartTime</strong>: time when the traffic started</li>
          <li>
            <strong>LastResetTime</strong>: last time when periodic counters have
            been reset</li>
          <li>
            <strong>CurrentTime</strong>: current time</li>
          <li>
            <strong>ElapsedTime</strong>: time elapsed since StartTime (if C) or LastResetTime (if P)</li>
          <li>
            <strong>Rate</strong>: number of new calls per second</li>
          <li>
            <strong>IncomingCall</strong>: number of incoming calls</li>
          <li>
            <strong>OutgoingCall</strong>: number of outgoing calls</li>
          <li>
            <strong>MsgRecvPerS</strong>: number of messages received per second</li>
          <li>
            <strong>MsgSendPerS</strong>: number of messages sent per second</li>
          <li>
            <strong>UnexpectedMsg</strong>: number of unexpected messages</li>
          <li>
            <strong>CurrentCall</strong>: number of currently opened calls</li>
          <li>
            <strong>InitSuccessfulCall</strong>: number of successful init scenarios</li>
          <li>
            <strong>TrafficSuccessfulCall</strong>: number of successful traffic scenarios</li>
          <li>
            <strong>DefaultSuccessfulCall</strong>: number of successful default scenarios</li>
          <li>
            <strong>AbortSuccessfulCall</strong>: number of successful abort scenarios</li>
          <li>
            <strong>FailedCall</strong>: number of failed calls</li>
          <li>
            <strong>FailedRefused</strong>: number of failed calls because they were refused</li>
          <li>
            <strong>FailedAborted</strong>: number of failed calls because they were aborted</li>
          <li>
            <strong>FailedTimeout</strong>: number of failed calls because they timed out</li>
          </ul>  
          <p>If actions "start-timer" and "stop-timer" exist in the scenario, the following counter are updated : </p> 
          <ul>
          <li>
            <strong>ResponseTime</strong>: average response time for the period (done in (P)eriotic and (C)umulative mode simultaneous)</li>
          <li>
            <strong>ResponseTimeRepartition</strong>: response time repartition for a period according to the distribution set with the configuration parameter.<br/>
             Default distribution values are : &lt;50, &lt;75, &lt;100, &lt;150, &lt;300, &lt;5000, &gt;=5000 in ms. </li>
        </ul>
        <p>The last two counters are updated when the action "stop-timer" is executed in the scenario whether the call succed or not.</p>
       
        <p>Here is an example of a global statistic file (some counters have been
          removed):</p>
        <source><![CDATA[StartTime;LastResetTime;CurrentTime;ElapsedTime(P);ElapsedTime(C);Rate(P);Rate(C);IncomingCall(P);IncomingCall(C);
2004-12-02 11:11:01;2004-12-02 11:11:01;2004-12-02 11:11:01;00:00:00;00:00:00;111.111;111.111;0;0;
2004-12-02 11:11:01;2004-12-02 11:11:05;2004-12-02 11:11:06;00:00:05;00:00:05;40.7837;40.9018;0;0;
2004-12-02 11:11:01;2004-12-02 11:11:10;2004-12-02 11:11:11;00:00:05;00:00:10;50.9287;45.9128;0;0;
2004-12-02 11:11:01;2004-12-02 11:11:15;2004-12-02 11:11:16;00:00:05;00:00:15;50.729;47.5145;0;0;
2004-12-02 11:11:01;2004-12-02 11:11:20;2004-12-02 11:11:21;00:00:05;00:00:20;50.729;48.3179;0;0;
2004-12-02 11:11:01;2004-12-02 11:11:25;2004-12-02 11:11:26;00:00:05;00:00:25;50.9287;48.838;0;0;
2004-12-02 11:11:01;2004-12-02 11:11:30;2004-12-02 11:11:31;00:00:05;00:00:30;50.729;49.153;0;0;]]>
          </source>
          <p>Here is a real example of generated file: <a href="server-stat.csv"> server-stat.csv </a>.</p>
      </section>
      <section id="stats_responsetime">
        <title>Response time statistics</title>
        <p>While global statistics are used to monitor the traffic over time, 
          response time statistics are meant to be used to measure time between 
	  two messages. This is what is usually used in performance test campaigns.</p>
        <figure alt="Diameter Response time timer" src="images/startstoptimer.png" width="608"/>
        <note>To activate response time statistics,
          you must specify the data-log-* parameters in the configuration file
          <strong>AND</strong> manage the timer in the scenario, which means to have a 
          <a href="#action_start-timer"><![CDATA[<start-timer>]]></a> and
          <a href="#action_stop-timer"><![CDATA[<stop-timer>]]></a> in the scenario
          file.</note>
        <warning>Do not imbricate timers like this:<br/>
        <source><![CDATA[<start-timer>
...
<start-timer>
...
<stop-timer>
...
<stop-timer>
        ]]>
        </source>
        Always stop a timer before starting a new one:
        <source><![CDATA[<start-timer>
...
<stop-timer>
...
<start-timer>
...
<stop-timer>
        ]]>
        </source></warning>
        <p>The parameters to be set in the configuration file are the following:</p>
        <ul>
          <li>1) <a href="#data_log_period">data-log-period</a>
            <p>This number specifies the time interval (in seconds) at which the 
	    logs are dumped to file.<br/>
	    Example: if set to 10, the logs are dumped every 10 seconds.</p>
          </li>
          <li>2) <a href="#data_log_number">data-log-number</a>
            <p>This number specifies the interval in number of messages at which the 
	    logs are dumped to file.<br/>
	    Example: if set to 500, the logs are dumped every 500 messages.</p>
          </li>
          <li>3) <a href="#data_log_file">data-log-file</a>
            <p>It specifies the file to which the logs are dumped. Warning: 
	    if not set, no logs are available, even on the display screen !</p>
          </li>
          <li>4) <a href="#data_log_rtdistrib">data-log-rtdistrib</a>
            <p>This number specifies the width of the distribution 
	    of the response times (in milliseconds !!) to be counted during the measurement interval. 
          Here is an example, with the value set to 2000:</p>
            <figure alt="data-log-rtdistrib example" src="images/data-log-rtdistrib-example.jpg" width="708"/>
          </li>
        </ul>
        <p>If data-log-period and data-log-number are both defined, then they are simultaneously active:
        the logs are dumped every X seconds AND every Y messages.</p>
        <p/>
        <p>If data-log-rtdistrib is not defined in the configuration file, then the response time 
	  statistics look like:</p>
        <source><![CDATA[time-ms;response-time-ms;
2210.899902;2159.582000;
3204.348877;2203.527000;
4124.591064;2123.738000;
5150.986084;2150.094000;
6124.566895;2123.638000;
7190.973877;2186.730000;
8151.060059;2150.058000;
9144.521973;2143.523000;
10171.154053;2166.825000;
11184.657959;2180.298000;
12121.958984;2120.847000;
13151.222900;2146.783000;
14151.293945;2150.089000;
15174.738037;2170.263000;
16201.378906;2196.880000;
17151.288086;2149.990000;]]></source>
        <p>where the response-time-ms values correspond to the average response time since the previous statistics response time has been logged.</p>
        <p>If all data-log-* parameters are defined in the configuration file, then the response time 
	  statistics look like:</p>
        <source><![CDATA[Dump Periodic;
1149;1;
1156;4;
1169;1;
1196;1;
1216;1;
Dump Periodic;
1140;1;
1149;2;
1156;4;
1209;1;
1216;2;

....

Dump Cumulative;
1115;1;
1116;1;
1118;1;
1119;1;
1121;1;
1123;2;
1127;3;
1128;1;
1129;2;
1130;12;
1131;3;
1132;3;
1133;4;
1135;1;
1136;8;
1137;11;
1138;12;
...
]]></source>

<p>This gives the distribution of the number of calls that have been counted during the measurement interval and globally 
for each response time value between 0 and data-log-rtdistrib milliseconds.</p>

      </section>
      <p class="pageBreakBefore"></p>
      <section id="stats_protocol">
        <title>Protocol statistics</title>
        <p>Protocol statistics are used to get global information on the traffic for a specified protocol. 
	  To activate protocol statistics, you must set the protocol parameters 
	  in the configuration file. Those parameters are the following:</p>
        <ul>
          <li>1) <a href="#display-protocol-stat">display-protocol-stat</a>
            <p>Setting this parameter to true enables the protocol statistics. 
	    If it is not set to true, you will not get any protocol statistics at screen of in log files, 
	    even if the following parameters are set.</p>
          </li>
          <li>2) <a href="#log-protocol-stat-period">log-protocol-stat-period</a>
            <p>This number specifies the time interval (in seconds) at which the logs are dumped.<br/>
	    Example: if set to 5, the logs are dumped every 5 seconds.</p>
          </li>
          <li>3) <a href="#log-protocol-stat-name">log-protocol-stat-name</a>
            <p>This parameter specifies the names of the protocols for which the statistics are set. 
	    Put "all" to get statistics for all the used protocols. Otherwise, state 
	    the names of the protocols separated by semi-colons.<br/>
	    If you specify the names of several protocols and all, it will only consider 
	    the "all" keyword" and display statistics for all the protocols.<br/>
	    If you do not specify this parameter, you do not get any protocol statistics.
	    </p>
          </li>
          <li>4) <a href="#log-protocol-stat-file">log-protocol-stat-file</a>
            <p>It specifies the file to which the logs are dumped.</p>
          </li>
        </ul>
        <p>If the display-protocol-stat parameter is set to true, but the 
	  log-protocol-stat-period is set to zero, you will not get any statistics 
	  displayed on screen. In this case, if you define the log-protocol-stat-file, 
	  you will get statistics in the file, even though you do not see them on screen.</p>
        <p>Here is an example of the protocol statistics screen that you get (example from a TCAP execution):</p>
        <source><![CDATA[|--------------------------------+---------------------+-----------------------|
|                                |  Periodic value     |   Cumulative value    |
| primitive                      |     sent | received |      sent |  received |
|--------------------------------+---------------------+-----------------------|
| MGT                            |        0 |        0 |         0 |         0 |
| NO_PRIMITIVE                   |        0 |        0 |         0 |         0 |
| SCCP_N_COORD                   |        0 |        0 |         0 |         0 |
| SCCP_N_COORD_RES               |        0 |        0 |         0 |         0 |
| SCCP_PC_STATUS                 |        0 |        0 |         0 |         0 |
| SCCP_USER_STATUS               |        0 |        0 |         0 |         1 |
| SWITCH_DONE                    |        0 |        0 |         0 |         0 |
| SWITCH_STARTED                 |        0 |        0 |         0 |         0 |
| TC_BEGIN                       |        0 |       77 |         0 |     18280 |
| TC_CONTINUE                    |       77 |       77 |     18280 |     18277 |
| TC_END                         |       76 |        0 |     18276 |         0 |
| TC_NOTICE                      |        0 |        0 |         0 |         0 |
| TC_P_ABORT                     |        0 |        0 |         0 |         0 |
| TC_UNI                         |        0 |        0 |         0 |         0 |
| TC_U_ABORT                     |        0 |        0 |         0 |         0 |
|                                |                     |                       |
|                                |                     |                       |
|                                |                     |                       |
|                                |                     |                       |
|----------------------------------------- Next screen : Press the same key ---|]]></source>

      </section>
      <section id="stats_scenario">
        <title>Scenario statistics</title>
        <p>Scenario statistics are used to get information for each type of scenario 
	  that exist in the scenario file. Those can be: init, traffic, default and abort scenarios. 
	  To activate scenario statistics, the <a href="#display-scenario-stat">display-scenario-stat</a> 
        parameter must be set to true in the configuration file: 
        </p>
        <p>Here is an example of the scenario statistics screen 
	  (example from traffic scenario in a TCAP execution):</p>
        <source><![CDATA[|--------------------------+-------------------------+-------------------------|
|                          | Messages   | Retrans    | Timeout    | Unexp.     |
|             TC_BEGIN <-- |      20702 |          0 |          0 |          0 |
|          TC_CONTINUE --> |      20702 |          0 |          0 |          0 |
|          TC_CONTINUE <-- |      20699 |          0 |          0 |          0 |
|               TC_END --> |      20699 |          0 |          0 |          0 |
|                          |                         |                         |
|                          |                         |                         |
|                          |                         |                         |
|                          |                         |                         |
|                          |                         |                         |
|                          |                         |                         |
|                          |                         |                         |
|                          |                         |                         |
|                          |                         |                         |
|                          |                         |                         |
|                          |                         |                         |
|                          |                         |                         |
|                          |                         |                         |
|                          |                         |                         |
|                          |                         |                         |
|                          |                         |                         |
|                          |                         |                         |
|--------------------------+-------------------------+-------------------------|
]]></source>
        <warning>The scenario statistics are only displayed on screen, no logs are 
	dumped to file.</warning>
      </section>
      <section>
        <title>Getting statistics out of response time raw data</title>
        <p>Once you have the raw statistics data, you can use a variety
          of tools coming with Seagull to analyse the datas and get various
          statistics out of it: Number of values, minimum value, maximum value, 
          average value, variance, standard deviation and N-th percentile.</p>
        <p>A schema that summarizes the various tools:</p>
        <figure alt="Statistics principle" src="images/statistics.png" width="923" />
        <ul>
          <li>
            <strong>csvsplit</strong> is used to create a reduced CSV file 
            from the raw CSV data. csvsplit combines two features:
            <ul>
              <li>Sample raw CSV data by taking one measure out of "r"</li>
              <li>Suppress the beginning of raw CSV data to remove unwanted
              "startup" data</li>
            </ul>
            <p>Usage:</p>
            <source><![CDATA[$ csvsplit
Syntax : csvsplit <in csv file> <out csv file>
         [-skip n] skip the n first values (default 0)
         [-ratio r] let 1 out of r value (default 10)]]></source>
            <p></p>
          </li>
          <li>
            <strong>computestat.ksh</strong> is used to compute the statistics 
            from the raw or sampled CSV data. computestat.ksh relies on <a href="#octave">Octave</a>
            to compute reliable statistical results.
            <p>Usage:</p>
            <source><![CDATA[$ computestat.ksh -help
Command line syntax of /usr/local/bin/computestat.ksh - options
-in <file name>             : input file (default file.csv)
-out <file name>            : output file (default file.save)
-nth <percentile>           : nth percentile calculus (default 95)
-help                       : display the command line syntax]]></source>
            <p>The output of computestat.ksh is a text file like the following:</p>
            <source><![CDATA[[Using file        : client-rtt.2004-12-02.11:11:01.016.csv.y]
[number values     : 23136]
[minimum value     : 1.267000]
[maximum value     : 29.074000]
[average value     : 3.321995]
[variance          : 0.803202]
[standard deviation: 0.896216]
[95th percentile   : 5.410000]]]></source>
            <p></p>
          </li>
          <li>
            <strong>plotstat.ksh</strong> is used to create graphics from the raw or sampled  
            CSV data. plotstat.ksh relies also on <a href="#octave">Octave</a>
            to create <a href="http://en.wikipedia.org/wiki/Png">PNG</a> graphical files.
            <p>Usage:</p>
            <source><![CDATA[$ plotstat.ksh -help
Command line syntax of /usr/local/bin/plotstat.ksh - options
-in <file name>             : input file (default file.csv)
-out <file name>            : output file (default file.png)
-stat <file name>           : input stat file name (default no file)]]></source>
            <p class="page">If you specify a statistics results file that has been computed
          with computestat.ksh through the -stat option, then two additional
          plots will be drawn: one line for the average time and one line for
          the percentile.</p>
            <p class="pageBreakBefore"></p>
            <p>Here is an example of the output of plotstat.ksh:</p>
            <figure alt="plotstat.ksh output" src="images/plotstat.png" width="640"/>
          </li>
        </ul>
      </section>
    </section>
    <p class="pageBreakBefore"></p>
    <section>
      <title>Logs and traces</title>
      <p>The logging feature of Seagull provides several logging levels
        that can be combined (except A and N that are exclusive):</p>
      <ul>
        <li>
          <strong>E</strong>-Errors
            <ul>
              <li>Syntax error in config or scenario files</li>
            <li>Unable to open a file</li>
          </ul>
        </li>
        <li>
          <strong>W</strong>-Warnings - non blocking errors
            <ul>
              <li>No init scenario</li>
              <li>No more call context availables</li>
          </ul>
        </li>
        <li>
          <strong>T</strong>-Traffic events
            <ul>
              <li>Unexpected messages</li>
            <li>Refused calls</li>
            <li>Incorrect state</li>
          </ul>
        </li>
        <li>
          <strong>M</strong>-Messages (decoded messages)</li>
        <li>
          <strong>B</strong>-Buffer (hex dumps)</li>
        <li>
          <strong>V</strong>-Verdict (Trace the result of each call with its session-id in the log file) <br/>
            If the call has no session id, no logs are traced.<br/>
            Be awared that the session-id may not be unique in the log file.<br/>
            The "Init" section is considered as a independant call.
            <ul>
              <li>passed : call is succesful</li>
              <li>failed : call is failed</li>
          </ul>
        </li>
        <li>
          <strong>U</strong>-User logs (possibility to user to add user comments in the log file)</li>
        <li>
          <strong>A</strong>-All</li>
        <li>
          <strong>N</strong>-None</li>
      </ul>
      <p>The log level is specified in the <a href="#cli_help">command line</a>, using <code>-llevel</code>
        option. Example: <code>-llevel EWT</code> will log Errors, Warnings and Traffic
        events.</p>
      <note>By default, all log entries are time-stamped. This is costly in terms
        of CPU time for the test tool. These time-stamps can be disabled by using
        the "<code>-notimelog</code>" command line option when launching the
        tool.</note>
    </section>
    <section id="config">
      <title>Configuration files</title>
      <p>There are 3 different configuration files:</p>
      <ul>
        <li>
          <a href="#config_generic">Generic</a> configuration file - describing traffic and network parameters</li>
        <li>
          <a href="#config_dict">Protocol dictionary</a> configuration file - rarely to be edited </li>
        <li>
          <a href="#config_scenario">Scenario</a> file - describing the sequence of messages to exchange 
          with the system under test and intermediate actions to perform</li>
      </ul>
      <figure alt="Config files" src="images/conf_files.png" width="424"/>
      <p/>
      <section id="config_generic">
        <title>Generic configuration</title>
        <p>The generic configuration file describes the network environment
        as well as traffic parameters.</p>
        <anchor id="cfg_transport"/>
        <p>The network environment is described by "<a href="#ref_transport">transport channel 
        entities</a>". The transport entity is then used as an attribute of <a href="#cmd_send"><code>send</code>
          </a> and
        <a href="#cmd_send"><code>receive</code>
          </a> scenario commands, as well as during the 
        opening of the transport channel (see below). </p>
        <p></p>
        <source>
<![CDATA[<!-- Synchro example -->
<?xml version="1.0" encoding="ISO-8859-1"?>
<configuration name="Simple IP Server Conf">

<define entity="transport"
    name="trans-ip-v4"
    file="libtrans_ip.so"
    create_function="create_cipio_instance"
    delete_function="delete_cipio_instance"
    init-args="type=tcp">
  </define>
<!-- Then you specify the opening of the channel, on the transport previously described. -->

<!-- For a server listening to port 15000, interface "192.168.0.13", it will look like this: -->

<define entity="channel"
    name="channel-1"
    protocol="command-synchro-v1"
    transport="trans-ip-v4"
    open-args="mode=server;source=192.168.0.13:15000">
  </define>

<!-- For a client sending messages to port 15000 on interface "192.168.0.13", it will look like this: -->
<define entity="channel"
    name="channel-1"
    protocol="command-synchro-v1"
    transport="trans-ip-v4"
    open-args="mode=client;dest=192.168.0.13:15000">
</define>]]>
	</source>
        <p>You can also specify <a href="#ref_traffic_param">traffic parameters</a>
        in the configuration file, like the call rate, the name of the statistics
        file, etc.</p>
        <source><![CDATA[  <define entity="traffic-param"
          name="call-rate"
          value="10">
  </define>	
  <define entity="traffic-param"
          name="display-period"
          value="1">
  </define>

  <define entity="traffic-param"
          name="log-stat-period"
          value="5">
  </define>

  <define entity="traffic-param"
          name="log-stat-file"
          value="../logs/client-stat.csv">
  </define>
]]></source>
      </section>
      <section id="config_dict">
        <title>Protocol dictionary</title>
        <p>In Seagull, messages and parameters of protocols used in a scenario
        are described in an XML dictionary. This allows a great flexibility to 
        add new messages or parameters. You can create as many dictionaries as you want,
        for example to work with different flavors or versions of a protocol.</p>
        <p>To specify the dictionary, use the -dico option in the command line:</p>
        <source> -dico ../config/[dictionary-name].xml </source>
        <p>To be able to work with a multi-protocol scenario, specify several dictionaries as arguments of the -dico option:</p>
        <source> -dico ../config/[dictionary_1-name].xml ../config/[dictionary_2-name].xml</source>
        <p>A dictionary contains several XML sections: protocol, types, header, body, dictionary:</p>
        <section>
          <title>Protocol</title>
          <p>"protocol": this is the top level section. Depending on the protocol, 
          some attributes can be configured there:</p>
          <ul>
            <li>Common for all protocols
              <ul>
              <li><strong>name</strong>: a name used to identify the protocol in the config file</li>
              <li><strong>type</strong>: can be "text" (like XCAP or H248 text), "binary" (like Diameter), "external-library" (like OCTCAP) or "binary-body-not-interpreted" (to support some custom protocols)</li>
              <li><strong>use-transport-library</strong>: "trans-ip" (TCP or UDP), "trans-extsctp" for SCTP, "trans-octcap" for OCTCAP (this refers to the name of the library file).</li>
              </ul>
            </li>
            <li>For binary type
              <ul>
              <li><strong>padding</strong> (optional): padding to be used for the message length. A padding of 4 makes sure that the message size is a multiple of 4 octets.</li>
              <li><strong>length</strong> (optional): by default, Seagull includes the headers to compute the message length. 
              By putting length="header-excluded", Seagull does not include the headers to compute the message length. 
              By adding &lt;start-length/&gt; in the header,
              the length will be computed starting from this point.</li>
              <source>Example:
             <![CDATA[
<header name="Message" length="msg-length" type="message-type">
    <fielddef name="some-field1" size="4" unit="octet"></fielddef>
    <start-length/>
    <fielddef name="msg-length" size="2" unit="octet"></fielddef>
    <fielddef name="message-type" size="4" unit="octet"></fielddef>
</header>]]>
</source>


              </ul>
            </li>
            <li>For text type
              <ul>
              <li><strong>filter</strong>: to specify a filter to be used when reading the XML scenario before sending it. 
              Used to remove heading and trailing spaces or tabs, add additional CR/LF, ....
              <p>Example: "lib=libparser_h248.so;function=filter_h248"</p></li>
              <li><strong>field-separator</strong>: to specify the text sequence to be appended to each line in the XML scenario. 
              <p>Example: field-separator="\r\n" will replace the end of line of the scenario with "\r\n".</p></li>
              <li><strong>body-separator</strong>: text sequence to be added between the header and the body sections. 
              <p>Example: body-separator="\r\n" for XCAP, body-separator="{" for H248 text.</p></li>
              </ul>
            </li>
            <li>external-library type
              <ul>
              <li><strong>context-factory-constructor</strong>: name of the constructor method of message (which is defined in the external library).  </li> 
              <li><strong>context-factory-destructor</strong>: name of the destructor method of message (which is defined in the external library).</li> 
              </ul>
            </li>
            <li>binary-body-not-interpreted type
              <ul>
              <li></li>
              </ul>
            </li>
          </ul>
          <fixme author="Olivier">Add context-factory explanations</fixme>
        </section>
        <section>
          <title>Types</title>
          <p>"types": this section contains all the types needed for the protocol. An example of 
            the Types section for the Diameter protocol is available <a href="diameter.html#Types">there</a>.</p>
          <p>This section is optional (but becames mandatory if the protocol needs specific types).</p>  
        </section>
        <section>
          <title>Header</title>
          <p>"header": this section contains the description of the message header. An example of 
            the Header section for the Diameter protocol is available <a href="diameter.html#Header">there</a>.<br/>
            "fielddef" tags define elements of the header.<br/></p>
            <p>For a text protocol, all fields have the string type and they can have "regexp" tags to define them.<br/>
            Example (SIP protocol):<br/>
            <source><![CDATA[<fielddef name="call-id"
          format="call-id: $(field-value)\r\n">
  <regexp name="call-id"
          expr="[Cc][Aa][Ll][Ll]-[Ii][Dd][   ]*:[  ]*([!-}]*).*$"
          nbexpr="2"
          subexpr="1">
  </regexp>
</fielddef>]]></source></p>
            <p>For other protocols, several attributes are needed.<br/>
            Example (OCTCAP protocol):<br/>
            <source><![CDATA[<fielddef name="uid"  type="number"
          set-function="set_primitive_uid"
          get-function="get_primitive_uid">
</fielddef>]]></source></p>
          <p>This section is mandatory.</p> 
          <table>
            <caption>List of fielddef attributes</caption>
            
            <tr>
              <th>Name</th>
              <th>Description</th>
              <th>Example</th>
            </tr>
            <tr>
              <td>name</td>
              <td>Name of the field. Any string without spaces.</td>
              <td>-</td>
            </tr>
            <tr>
              <td>size</td>
              <td>Size of the field.</td>
              <td>2</td>
            </tr>
            <tr>
              <td>unit</td>
              <td>Unit of the size.</td>
              <td>octet</td>
            </tr>
            <tr>
              <td>type</td>
              <td>Optional. Type of the size (number, string or a type defined in the dictionary "types" section)</td>
              <td>number</td>
            </tr>
            <tr>
              <td>mask</td>
              <td>Optional. For binary protocol. Mask of the field. If only a part of the field is significant, a mask can be applied to the value of the field.</td>
              <td>124</td>
            </tr>
            <tr>
              <td>to-string</td>
              <td>Optional. For external protocol. Name of the function to convert the field from an integer value to a string value of the field.</td>
              <td>-</td>
            </tr>
            <tr>
              <td>from-string</td>
              <td>Optional. For external protocol. Name of the function to convert the field from a string value to an integer value of the field.</td>
              <td>-</td>
            </tr>
            <tr>
              <td>set-function</td>
              <td>Optional. For external protocol. Name of the function to set the value of the field.</td>
              <td>-</td>
            </tr>
            <tr>
              <td>get-function</td>
              <td>Optional. For external protocol. Name of the function to get the value of the field.</td>
              <td>-</td>
            </tr>
            <tr>
              <td>default</td>
              <td>Optional. Set a default value for the field.</td>
              <td>-</td>
            </tr>
            <tr>
              <td>config-field</td>
              <td>Optional. If the value if set in the configuration file, name of the parameter of the configuration file.</td>
              <td>-</td>
            </tr>
         </table>   
        </section>
        <section>
          <title>Body</title>
          <p>"body": this section contains the description of the message body (which comes after the header). 
          An example of the Body section for the Diameter protocol is available <a href="diameter.html#Body">there</a>.</p>
          <p>This section is mandatory.</p>
        </section>
        <section>
          <title>body-method</title>
          <p>"body-method": this section contains the methods to be used to parse the body. It is composed of several
          "def-method" sections.</p>
          <ul>
            <li><strong>name</strong>: Name of the body-method. It can be anything.</li>
            <li><strong>method</strong>: It can be "length" (the length of the body to be parsed is indicated by the param parameter) 
            or "parser"</li>
            <li><strong>param</strong>: For a "length" method, it specifies the parameter to be used to indicate the body length 
            (Example: param=Content-Length).
            For a "parser" method, it indicates the library and the function to be used 
            (Example for XCAP: "lib=libparser_xml.so;function=parse_xml"; for H248: "lib=libparser_h248.so;function=parse_h248")</li>
          </ul>
          <p>Example:</p>
          <fixme author="Olivier">Add body-method example</fixme>
          <p>This section is mandatory.</p>
        </section>
        <section>
          <title>external-method</title>
          <p>"external-method": this section contains the methods to be used to encode fields. It is composed of several
          "defmethod" sections. The concerned fields must refer to this method in the 'set-value' action in the 
          scenario with the attribute 'method' (see "<a href="#action_set-value">set_value</a>" action). 
          For now, "crypto_method" from "libtrans_iptls.so" library is the only available method.<br/>
          An example is described for the SIP protocol at <a href="sip.html#sip_authentication">SIP authentication</a>. </p>
          <ul>
            <li><strong>name</strong>: Name of the method. It can be anything.</li>
            <li><strong>param</strong>: It indicates the library and the function to be used.<br/> 
            (Example: "lib=libtrans_iptls.so;function=crypto_method")</li>
          </ul>
          <p>Example:</p>
          <source><![CDATA[<external-method>
  <defmethod name="authentication"
             param="lib=lib_crypto.so;function=crypto_method">
  </defmethod>
</external-method>]]></source>
        <p>This section is optional.</p>
	<table>
            <caption>List of general purpose methods</caption>
            <tr>
              <th>Name</th>
              <th>Library</th>
              <th>Description</th>
              <th>Supported Seagull version</th>
            </tr>
            <tr>
              <td>sys_time_ms</td>
              <td>lib_generalmethods.so</td>
              <td>System time in milliseconds.</td>
              <td>&gt;1.7</td>
            </tr>
	</table>
        </section>

        <section id="ref_dictionary">
          <title>Dictionary</title>
          <p>"dictionary": this section contains all possible messages and parameters.</p>
          <p>In addition, several attributes are available:</p>
            <ul>
            <li><strong>session-method</strong>: It can be "field", in which case a session or "call" is identified
            with a specified protocol field, or it can be "open-id", in which case a session or "call" is identified with
            the "open-id" (e.g. a socket id in case of HTTP)). 
            "open-id" is currently implemented only for "text" and "binary" protocols.</li>
            <li><strong>session-id (mandatory for a "field" session-method)</strong>: Only for a "field" session-method. 
            It specifies the field to be used to identify each session (or "call").</li>
            <li><strong>out-of-session-id (optional for a "field" session-method)</strong>: Only for a "field" session-method. 
            It specifies a field to be used in backup of the one defined by the session-id attribute.</li>
            </ul>
            <p>This section is mandatory.</p>
        </section>
      </section>
    </section>
    <section id="ref_correlation">
      <title>Correlation</title>
      <p>In general, instances of a scenario (aka calls) are identified, see <a href="#ref_dictionary"> Dictionary</a>, 
      either with a session-id (a protocol field) or with an open-id (a socket id).</p> 
      
      <p>In some cases, the session-id cannot be unique during the whole call: its value may be changed during the call and/or 
      a different field of the message (header or body) is used for the rest of the call.
      In particular this can be the case if several channels are used during the scenario.<br/>
      Here is an example of such call flow for which Seagull could play the role of client, server_1 or server_2:</p>
      <source><![CDATA[   
  client                 server_1               server_2              |
    |                                                                 | 
    |                                                                 | The client defines the session-id-1
    | session-id-1         |                                          |
    |--------------------->|                                          |
                           |                                          | 
                           |                                          | The server_1 defines session-id-2 and sends it to the client via a field of the message
      session-id-1         |                                          |
    |<---------------------|                                          | The client receives a message with session-id-1 as session-id and that contains 
                           |                                          | the value session-id-2 in another field of the message.
                           |  session-id-2        |                   | The client keeps this new session-id for the call (storing it into its "map")
                           |--------------------->|                   |
                           |  session-id-2        |                   |
                           |<---------------------|                   |
                                                  |                   |
                                            PAUSE |                   |
                     session-id-2                 |                   |
    |<--------------------------------------------|                   | The client receives a message with session-id-2 as session-id
    |                session-id-2                 |                   | It recognizes the call and continues it
    |-------------------------------------------->|                   |
    |                      
    
    ...
        
    ]]></source>
    <p></p>
      
      <p>To support these situations Seagull provides the "correlation" feature. 
      It allows to use several session-ids for the same call. <br/>

      At Seagull level and for each channel, a list (called "map") of the known session-ids is built 
      to match received messages to current calls. 
      A constraint is that Seagull must know the alternative session-id of a call before it can recognize any message 
      with this alternative session-id. <br/>
            
      From a user perspective, the scenario includes a "correlation" section (detailed below) and the "label" tag is used 
      from the scenario commands (e.g. send and receive) to refer to the specific processing defined in the correlation section.<br/>
            
      The correlation section is optional in the scenario file but it must be present to enable the correlation feature. 
      If not present, the "label" tags are ignored in the scenario commands and a call can only be identified by a single session-id value.
      </p>
      <p>Example of a correlation section, see below for the details of the sub-sections:</p>
          <source><![CDATA[
<correlation>
   <channel name="channel-1">
      <retrieve>
         <search-in-map name="call-id"></search-in-map>
      </retrieve>

      <command name="command-1">
         <pre-action>
            <!-- For each new call, increment the callid counter -->
            <inc-counter name="callid-counter"> </inc-counter>
            <!-- And set the call-id field -->
            <set-value name="call-id"
                       format="$(callid-counter)@127.0.0.1"></set-value>
         </pre-action>
     
         <post-action>
            <store name="SID" entity="call-id"></store>
            <insert-in-map channel="channel-1" name="SID"></insert-in-map>
         </post-action>
      </command>

      <command name="command-1b">
         <post-action>
            <store name="alt-sid" entity="o"></store>
            <insert-in-map channel="channel-2" name="alt-sid"></insert-in-map>
         </post-action>
      </command>
 
   </channel>
   <channel name="channel-2">
      <retrieve>
         <search-in-map name="call-id"></search-in-map>
      </retrieve>
   </channel>
</correlation>
]]></source>
       
      
      <p>For each channel used in the scenario, a "channel" sub-section must be added. 
      It contains at least the retrieve method and optionnally some commands.</p> 

      <p>The "retrieve" sub-section defines all the fields (defined in the dictionary) in which the session-id can 
      be located. For each such field, a "search-in-map" tag must be added.<br/>
      For a new received message on a given channel, Seagull gets the value of the field defined in "name" and searches in its "map" 
      of call contexts to match a known call.<br/>
      Example:</p>
   <source><![CDATA[   
   <retrieve>
     <search-in-map name="Session-Id"></search-in-map>
     <search-in-map name="HbH-id"></search-in-map>
   </retrieve>
   ]]></source>
      
       
      
      <p>The "command" sub-section can contain any other actions of the scenario but it must be present 
      to host an "insert-in-map" action when it is necessary to store a new value of session-id for a call.<br/>
      The "pre-action" tag defines the actions which must be done before the scenario command.<br/> 
	The "post-action" tag defines the actions which must be done after the scenario command.<br/>
      The "insert-in-map" action is specific to the correlation feature. 
      It inserts in the list of known session-ids for the given "channel" the value of the "entity" (that is defined in the dictionary).<br/>
      Example:</p>
   <source><![CDATA[
   <command name="command-1">
     <pre-action>
      <set-value name="HbH-id" format="$(HbH-counter)">
      </set-value>
     </pre-action>
     <post-action>
      <insert-in-map channel="channel-1" entity="HbH-id"></insert-in-map>
     </post-action>
   </command>
   ]]></source>
      

<warning>If no "insert-in-map" action is defined in the correlation section, then seagull implements a default behavior. 
      It processes messages by looking for the session-id field defined in the dictionary and inserting it in the map of the first channel 
      defined in the configuration file. this would not work in case of multiple channels.</warning>
      
      
      <p>Finally the correlation "commands" defined above are linked to the scenario by setting a "label" into the 
      scenario command (send).<br/>
      Example:</p>
      <source><![CDATA[
    <send channel="channel-1" label="command-1">
    <action>
      <start-timer></start-timer>
    </action>
    <command name="CER">
      <avp name="Origin-Host" value="seagull.ims.hpintelco.org"> </avp>
      <avp name="Origin-Realm" value="ims.hpintelco.org"> </avp>
      <avp name="Host-IP-Address" value="0x00010a03fc5e"> </avp> <!-- IPV4 10.3.252.94-->
      <avp name="Vendor-Id" value="11"> </avp>
      <avp name="Product-Name" value="HP Cx Interface"> </avp>
      <avp name="Origin-State-Id" value="1094807040"> </avp>
      <avp name="Supported-Vendor-Id" value="10415"> </avp>
      <avp name="Auth-Application-Id" value="167772151"> </avp>
      <avp name="Acct-Application-Id" value="0"> </avp>
      <avp name="Vendor-Specific-Application-Id">
        <avp name="Vendor-Id" value="11"></avp>
        <avp name="Auth-Application-Id" value="167772151"></avp>
        <avp name="Acct-Application-Id" value="0"></avp>
      </avp>
      <avp name="Firmware-Revision" value="1"> </avp>

    </command>
    <action>
      <stop-timer></stop-timer>
    </action>
  </send>]]></source>
      
    <p>An example of the correlation feature is proposed for the SIP protocol: <a href="sip.html#sip_correlation">SIP correlation example</a>. </p>  
      
      <section id="corr-openid">
      <title>Correlation with open id feature</title>
      <p>The open-id feature is compatible with the correlation one. <br/>
      The configuration is the same as a open id one:<br/>
      Example:
      <source><![CDATA[<define entity="channel"
    name="channel-2"
    protocol="xcap-protocol"
    transport="trans-1"
    global="no"
    open-args="mode=client;dest=127.0.0.1:8080">
  </define>

      ]]></source>  
      The traffic section is not changed except the label:<br/>
      Example:
      <source><![CDATA[<send channel="channel-2" label="command-2">
      <action>
        <open args="mode=client;dest=127.0.0.1:8080"></open>
      </action>
      <message> 
      ...]]></source>  
      </p>
      <p>The correlation section has to be defined like this :<br/>
      Example:
        <source><![CDATA[<channel name="channel-2">
    <retrieve>
      <search-in-map name="session-method-open-id"></search-in-map>
    </retrieve>

    <command name="command-2">
      <post-action>
        <insert-in-map channel="channel-2" name="default-session-id"></insert-in-map>
      </post-action>
    </command>

 </channel>]]></source>  
       "session-method-open-id" is the key word to define a search of the id of the call by the socket.<br/>
       "default-session-id" is the key word to let Seagull insert the id of the call into the map (here the socket of the call).<br/>
  </p>

      </section>
    </section>
    <section id="support">
      <title>Getting support</title>
      <p>For support on Seagull, please send your questions on Seagull users mailing list: 
      <a href="mailto:gull-users@lists.souceforge.net">gull-users@lists.souceforge.net</a>.
      You will likely get support from Seagull users.
      </p>
    </section>
    <section>
      <title>Reference</title>
      <p>This section is the reference for all values and parameters of Seagull.</p>
      <section id="config_generic_ref">
        <title>Generic configuration reference</title>
        <section id="transport_config">
          <title>Transport configuration</title>
          <warning>The sending segmentation is not implemented yet in Seagull. If the message cannot send entirely, 
          a log is put on the log-file to indicate it. No other particular treaments are done. <br/> 
          The receiving segmentation is implemented. If a message is not complete, it is stored and 
          the next buffer read is push at the end of stored 
          incomplete message. </warning>
          <p>The following table is a list of transport channel parameters, that can be present in
          the <a href="#config_generic">generic configuration file</a>.</p>
          <anchor id="ref_transport"/>
          <table>
            <caption>List of transport channel parameters (transport entity)</caption>
            <tr>
              <th>Name</th>
              <th>Description</th>
              <th>Recommended value</th>
            </tr>
            <tr>
              <td>name</td>
              <td>Name of the transport entity. Any string without spaces.</td>
              <td>-</td>
            </tr>
            <tr>
              <td>file</td>
              <td>Shared library to be used for transport.</td>
              <td>Value is "libtrans_ip.so" for TCP or UDP over IP, libtrans_iptls.so for TLS over IP (based on openssl library), "libtrans_extsctp.so" for SCTP (this one is 
	    based on an external SCTP library) and "libtrans_octcap.so" for TCAP.</td>
            </tr>
            <tr>
              <td>create_function</td>
              <td>Function used to create a transport instance</td>
              <td>Value is "create_cipio_instance" for IP-based protocols,  "create_ciptlsio_instance" for IP/TLS 
	    and "create_ctransoctcap_instance" for TCAP.</td>
            </tr>
            <tr>
              <td>delete_function</td>
              <td>Function used to delete a transport instance</td>
              <td>Value is "delete_cipio_instance" for IP-based protocols, "delete_ciptlsio_instance" for IP/TLS 
	    and "delete_ctransoctcap_instance" for TCAP. </td>
            </tr>
            <tr>
              <td>init-args</td>
              <td>Arguments to be passed to the transport library. The arguments are 
	    separated by semi-colons (;).</td>
              <td><ul>
              <li>For the "libtrans_ip.so", the possible values are:
                <ul>
                  <li>type = tcp (default=tcp)</li>
                  <li>decode-buf-len (default=4096): size of the reception buffer (maximum message size after re-assembly)</li>
                  <li>encode-buf-len (default=4096): size of the sending buffer (maximum message size to be sent (can be segmented))</li>
                  <li>read-buf-len (default=1024): amount of bytes to read on the IP socket at a time - several reads 
                    might be necessary if buffer is the message to read is bigger than the buffer (impact on performances)</li>
                  <li>close-wait-ms (default=10): value in milliseconds before the socket is actualy closed (used for SO_LINGER). </li>
                </ul>
              </li>
	      <li>For the "libtrans_iptls.so", the possible values are:
                <ul>
                  <li>method=SSLv23       : indicates the method of connection. This value corresponds to SSLv23_method</li>
                  <li>cert_chain_file=xxx : indicates the name of the certificate</li>
                  <li>private_key_file=yyy  : indicates the name of the private key</li>
		  <li>passwd=zzz            : this password protects the private key</li>
                  <li>secure              : indicates if the mode is secure at the begining of the traffic (yes/no , default:yes)</li>
                  <li>decode-buf-len (default=4096): size of the reception buffer (maximum message size after re-assembly)</li>
                  <li>encode-buf-len (default=4096): size of the sending buffer (maximum message size to be sent (can be segmented))</li>
                  <li>read-buf-len (default=1024): amount of bytes to read on the IP socket at a time - several reads 
                    might be necessary if buffer is the message to read is bigger than the buffer (impact on performances)</li>
                </ul>
              </li>
              <li>For the "libtrans_octcap.so", the possible parameters are the following (see 
              <a href="http://gull.sourceforge.net/doc/octcap.html#Transport+protocols+and+channels+for+TCAP">details here</a>):
                <ul>
                  <li>flavour (possible values: WBB, AAA, WAA, ABB)</li>
                  <li>path to the reference library (optional)</li>
                  <li>reference library (optional)</li>
                </ul>
              </li>
              </ul>
              </td>
            </tr>
          </table>
          <p></p>
          <table id="ref_channel">
            <caption>List of channel parameters (channel entity)</caption>
            <tr>
              <th>Name</th>
              <th>Description</th>
              <th>Recommended value</th>
            </tr>
            <tr>
              <td>name</td>
              <td>Name of the transport entity. Any string without spaces.</td>
              <td>-</td>
            </tr>
            <tr>
              <td>protocol</td>
              <td>Protocol to be used for this channel.</td>
              <td>The value must correspond to one of the protocol name defined in a dictionary.</td>
            </tr>
            <tr>
              <td>global</td>
              <td>Indicate if a channel is declared and used globally (opened once)
              or needs to be opened for each scenario call (using the "<a href="#open_action">open</a>" 
              action). By default, the channel is declared globally. adding <code>global="no"</code>
              will allow to open channels in the scenarios.</td>
              <td>-</td>
            </tr>
            <tr>
              <td>transport</td>
              <td>Transport to be used for this channel</td>
              <td>The value must correspond to one transport defined previously.</td>
            </tr>
            <tr>
              <td>reconnect</td>
              <td>Optional. If set to "yes", seagull tries to re-connect if the connection is lost.</td>
              <td>yes</td>
            </tr>
            <tr>
              <td>open-args</td>
              <td>Arguments to specify connexion parameters.<br/>
                <ul>
                  <li>libtrans_ip based channels:
                    <ul>
                      <li>mode (mandatory): "client" (first message on the channel is sent) or 
                                "server" (first message on the channel is received)</li>
                      <li>dest (mandatory): destination IP address/port to send messages</li>
                      <li>standby (optional): standy destination IP address/port to send messages.(Note that this feature is useful only when reconnect feature is used, in which case seagull tried to connect to the active and standby destinations alternatively)</li>
                      <li>source (optional): source IP address/port to send messages (if not specified,
                      the system chooses the best one)</li>
                    </ul>
                    Example of value for a client for a IP-based protocol: 
	    "mode=<strong>client</strong>;<strong>dest</strong>=127.0.0.1:3868"<br/>
                    Example of value for active and standby clients for a IP-based protocol: 
	    "mode=<strong>client</strong>;<strong>dest</strong>=127.0.0.1:3868;<strong>standby</strong>=127.0.0.1:3869"<br/>
	    Example of value for a server for a IP-based protocol: 
	    "mode=<strong>server</strong>;<strong>source</strong>=127.0.0.1:3868"
                  </li>
                  <li>libtrans_octcap based channels:
                    <ul>
                      <li>class (mandatory): Name of the OCSS7 stack</li>
                      <li>ossn (mandatory): Originating SSN used to connect Seagull
                      TCAP application to OCSS7 stack (one of the local OCSS7 SSN)</li>
                      <li>application (optional): Application ID used by Seagull
                      (refer to OCSS7 Application Developer's Guide)</li>
                      <li>instance (optional): Instance ID used by Seagull (refer to 
                      OCSS7 Application Developer's Guide)</li>
                    </ul>
                    Example: "class=SS7_Stack_2;ossn=20;application=2;instance=2"
                  </li>
                </ul>
                </td>
                <td> - </td>
            </tr>
          </table>
        </section>
        <section id="generic_config">
          <title>Generic configuration</title>
          <p>This table is a list of traffic parameters, that can be present in
        the <a href="#config_generic">generic configuration file</a>.</p>
          <anchor id="ref_traffic_param"/>
          <table>
            <caption>List of traffic parameters (<strong>traffic-param</strong> entity)</caption>
            <tr>
              <th>Name</th>
              <th>Description</th>
              <th>Recommended value</th>
              <th>Example</th>
            </tr>
            <tr>
              <td>call-rate</td>
              <td>Specify the call-rate in a number of calls per seconds. Only applicable 
	    to the client side.</td>
              <td>-</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="call-rate"
            value="500">]]></code> Indicates that Seagull will start with 
            a steady call rate of 500 calls per seconds.</td>
            </tr>
            <tr>
              <td>display-period</td>
              <td>Define the refresh rate of on-screen information. 0 means that
            on-screen information is not displayed. See also display-protocol-stat 
	    and display-scenario-stat to set statistics.</td>
              <td>1</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="display-period"
            value="1">]]></code> Refreshes the screen every one second.</td>
            </tr>
            <tr>
              <td>
                <anchor id="traffic_log_stat"/>log-stat-period</td>
              <td>log-stat-period is the periodicity, in seconds, of statistics dump in 
            the statistic file (log-stat-file parameter).</td>
              <td>60</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="log-stat-period"
            value="60">]]></code>: a new line in the statistic file is created
            every 60 seconds.</td>
            </tr>
            <tr>
              <td>log-stat-file</td>
              <td>The name of the statistic log file. The date is inserted between
            the name and the extension. <strong>WARNING</strong>: both log-stat-period and log-stat-file
            must be present for statistics to be activated.</td>
              <td>-</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="log-stat-file"
            value="client-stat.csv">]]></code>: the statistics are saved in 
            client-stat.2004-10-13.13:23:01.120.csv file.</td>
            </tr>
            <tr>
              <td>
                <anchor id="data_log_file"/>data-log-file</td>
              <td>The name of the response time data file. The date is inserted between
            the name and the extension. <strong>WARNING</strong>: you need to specify a file in order
            to activate the response time statistics.</td>
              <td>-</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="data-log-file"
            value="client-rtt.csv">]]></code>: the response time statistics are saved in 
            the file you specified.</td>
            </tr>
            <tr>
              <td>
                <anchor id="data_log_period"/>data-log-period</td>
              <td>The response time data is saved every n second period.
            If value is 0, then the <a href="#data_log_number">data-log-number</a> 
            traffic-param is used.</td>
              <td>1</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="data-log-period"
            value="10">]]></code>: the response time statistics are saved in 
            the file every 10 seconds (default is 1 second).</td>
            </tr>
            <tr>
              <td>
                <anchor id="data_log_number"/>data-log-number</td>
              <td>The response time data is saved every m numbers of data.
            This ensure that memory usage does not get too high.</td>
              <td>200</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="data-log-number"
            value="500">]]></code>: the response time statistics are saved in 
            every 500 measures (default is 200 measures).</td>
            </tr>
            <tr>
              <td>
                <anchor id="data_log_rtdistrib"/>data-log-rtdistrib</td>
              <td>Defines the value of the interval on which the messages are sampled. 
	    This value is in milliseconds.</td>
              <td>-</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
   name="data-log-rtdistrib"
   value="2000">
  </define>]]></code>
              </td>
            </tr>
            <tr>
              <td>response-time-repartition</td>
              <td>The intervals in which the response time measures are going to be 
            spreaded.</td>
              <td>-</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="response-time-repartition"
            value="25,50,75,100,125,150,200,250,300,350">]]></code>
              </td>
            </tr>
            <tr>
              <td>log-file</td>
              <td>The base name of the log file. The date is inserted between
            the name and the extension.</td>
              <td>-</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="log-file"
            value="client.log">]]></code>: the logs are saved in client.2004-10-13.13:23:01.120.log log file.</td>
            </tr>
            <tr>
              <td>files-no-timestamp</td>
              <td>To specify to not insert the date between
            the name and the extension in the log files names.</td>
              <td>-</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="files-no-timestamp"
            value="true">]]></code>: the logs are saved in "client.log" log file.</td>
            </tr>
            <tr>
              <td>
                <anchor id="display-protocol-stat"/>display-protocol-stat</td>
              <td>Enable (true) / disable (false) the protocol statistics. 
	    If you set this parameter to false, you do not get any protocol statistics 
	    neither on screen nor dumped to file.</td>
              <td>true</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
   name="display-protocol-stat"
   value="true">
  </define>]]></code>
              </td>
            </tr>
            <tr>
              <td>
                <anchor id="log-protocol-stat-period"/>log-protocol-stat-period</td>
              <td>Specify the interval in seconds at which the logs are dumped.<br/>
	    Example: if set to 5, the logs are dumped every 5 seconds.<br/>
	    If you only want the logs dumped to file and you do not want information 
	    displayed on screen, set this value to 0.</td>
              <td>-</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
   name="log-protocol-stat-period"
   value="5">
  </define>]]></code>
              </td>
            </tr>
            <tr>
              <td>
                <anchor id="log-protocol-stat-name"/>log-protocol-stat-name</td>
              <td>Specify the names of the protocols for which the statistics are set. 
	    Put "all" to get statistics for all the protocols used. Otherwise, state 
	    the names of the protocols separated by semi-colons.<br/>
	    If you specify the names of several protocols and all, it will only consider 
	    the "all" keyword" and display statistics for all the protocols.<br/>
	    If you do not specify this parameter, you do not get any protocol statistics.</td>
              <td>all</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
   name="log-protocol-stat-name"
   value="all">
  </define>]]></code>
              </td>
            </tr>
            <tr>
              <td>
                <anchor id="log-protocol-stat-file"/>log-protocol-stat-file</td>
              <td>Specify the file in which the protocol logs are dumped. 
	    The name of the protocol and the time and date are added to the filename 
	    to make it unique.</td>
              <td>-</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
   name="log-protocol-stat-file"
   value="../logs/server-protocol-stat.csv">
  </define>]]></code>
              </td>
            </tr>
            <tr>
              <td>
                <anchor id="display-scenario-stat"/>display-scenario-stat</td>
              <td>Enable (true) / disable (false) the scenario statistics. Remember 
	    that the scenario statistics are only displayed on screen, and not 
	    dumped to file.</td>
              <td>true</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
   name="display-scenario-stat"
   value="true">
  </define>]]></code>
              </td>
            </tr>
            <tr>
              <td>number-calls</td>
              <td>Number of calls to be done. It is available for client and server. 
            Once the number of calls is reached, no new calls are :<br/>
            - placed by the client(note that some additional calls can be placed, but no less) <br/>
            - accepted by the server.<br/>
            <strong>WARNING</strong>: the init section of the scenario is considered as one call for the server side.
              </td>
              <td>-</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="number-calls"
            value="1000">]]></code>: Placed (client) or accepted (server) at least 1000 calls.</td>
            </tr>
            <tr>
              <td>call-timeout-ms</td>
              <td>call-timeout-ms defines a timer after which, if the scenario is 
            stuck, the call will be closed and marked as failed. 0 means that this
            feature is de-activated.</td>
              <td>0</td>
              <td>
                <code><![CDATA[<define entity="traffic-param" name="call-timeout-ms" value="30000"> </define>]]></code> 
            specifies that a call that is stuck for more than 30s will
            be terminated.</td>
            </tr>
            <tr>
              <td>call-open-timeout-ms</td>
              <td>call-open-timeout-ms defines a timer after which, if the socket used by the call has not been properly open
            (if the system is overloaded for example), the call is marked as failed. 0 means that this
            feature is de-activated.</td>
              <td>0</td>
              <td>
                <code><![CDATA[<define entity="traffic-param" name="call-open-timeout-ms" value="5000"> </define>]]></code> 
            mark the call as failed if the socket creation process has not been achieved within 5s.</td>
            </tr>
            <tr>
              <td>call-timeout-behaviour-abort</td>
              <td>If a timeout is detected for a call, this parameter defines the behaviour before closing the call.  
            If it is set to "true", the section "abort" is executed before closing the call.<br/>
            A message is logged if this parameter is set to true and the section "abort" is missing in the sceanrio. </td>
              <td>true</td>
              <td>
                <code><![CDATA[<define entity="traffic-param" name="call-timeout-behaviour-abort" value="true"> </define>]]></code> 
            </td>
            </tr>
            <tr>
              <td>msg-check-level</td>
              <td>Type of message check. Possible values are "P" (Presence check) and
            "A" (Additional field check). The default value is "P".</td>
              <td>-</td>
              <td>
                <code><![CDATA[<define entity="traffic-param" name="msg-check-level" value="P"> </define>]]></code> checks that at least all parameters listed in the scenario
            are present.</td>
            </tr>
            <tr>
              <td>msg-check-behaviour</td>
              <td>Behaviour in case of message check fails. Possible values are "E" (log error and abort call) and
            "W" (log warning and continue call). The default value is "W".</td>
              <td>-</td>
              <td>
                <code><![CDATA[<define entity="traffic-param" name="msg-check-behaviour" value="E"> </define>]]></code>
              </td>
            </tr>
            <tr>
              <td>burst-limit (tuning)</td>
              <td>The burst limit corresponds to the number of new calls
            that Seagull can place in a period of one second. This is used to smooth
            the load at the beginning of a traffic or when traffic resumes.</td>
              <td>50</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="burst-limit"
            value="50">]]></code> Indicates that Seagull will not place more than
            50 new calls per seconds.</td>
            </tr>
            <tr>
              <td>max-send (tuning)</td>
              <td>max-send corresponds to the number of messages that can be sent
            in one scheduling loop.
	    NB: in future versions of the tool, this value will not be accessible anymore. It will be computed from the call rate
	    and the scenarii.</td>
              <td>(call rate) * nb_send_per_scene</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="max-send"
            value="250">]]></code>
              </td>
            </tr>
            <tr>
              <td>max-receive (tuning)</td>
              <td>max-receive corresponds to the number of messages that can be received
            in one scheduling loop.
	    NB: in future versions of the tool, this value will not be accessible anymore. It will be computed from the call rate
	    and the scenarii.</td>
              <td>at least (call rate) * nb_recv_per_scene</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="max-receive"
            value="250">]]></code>
              </td>
            </tr>
            <tr>
              <td>select-timeout-ms (tuning)</td>
              <td>Defines the value of the timer set when listening to the system, 
	    waiting for the messages. Counter in milliseconds.<br/>
	    For low call-rate, set a value at least lower than the smallest "wait" in the scenario.<br/>  
	    Be careful, the lower the value, the more CPU time will used.</td>
              <td>1000</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="select-timeout-ms"
            value="1000">]]></code>
              </td>
            </tr>
            <tr>
              <td>max-simultaneous-calls (tuning)</td>
              <td>max-simultaneous-calls is the maximum number of simultaneous calls that can
            be placed by the tool.</td>
              <td>(Duration of a call * call rate)* 1.2</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="max-simultaneous-calls"
            value="1000">
            </define>]]></code>
              </td>
            </tr>
            <tr>
              <td>model-traffic-select</td>
              <td>Specifies which distribution is selected to create new calls.Three different types are implemented: <br/>
                  -uniform : for each interval, seagull tries to reach the expected call rate, 
                   regardless of what happened during the lastest interval. With this value, 
                   the max-receive and max-send options are automatically set. <br/>
                  -best-effort : seagull tries to maintain the expected average call rate by 
                   adjusting the instantaneous call rate using the rates reached during the previous intervals.  <br/>
                   This is the default value. <br/>
                  -poisson : the real call rate varies around the expected call rate according 
                   to the Poisson distribution
              </td>
              <td>best-effort</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
            name="model-traffic-select"
            value="best-effort">
            </define>]]></code>
              </td>
            </tr>
            <tr>
              <td>external-data-file</td>
              <td>File from which the data are taken for the external data management.</td>
              <td>external_data.csv</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
   name="external-data-file"
   value="external_data.csv">
  </define>]]></code>
              </td>
            </tr>
            <tr>
              <td>external-data-select</td>
              <td>Defines the way the data are extracted from the external data file. Value can be sequential or random.</td>
              <td>sequential</td>
              <td>
                <code><![CDATA[<define entity="traffic-param"
   name="external-data-select"
   value="sequential">
  </define>]]></code>
              </td>
            </tr>
          </table>
        </section>
      </section>
      <section id="config_param">
        <title>Configuration parameters</title>
        <p>For text protocol, it is possible to define configuration parameters. They are set in the configuration 
        file and the value of the parameter can be used in the scenario.<br/>
        In the configuration file, the configuration parameters are defined:
        <source><![CDATA[<define entity="config-param"  name="]]><strong>param_ip</strong><![CDATA[" value="127.0.0.1"></define>
<define entity="config-param"  name="]]><strong>service</strong><![CDATA["  value="schooler"></define>]]></source>
        
        </p>
        <p>In the scenario, the value is restored in the message (example for SIP protocol):
        <source><![CDATA[<message>
  <![CDATA[INVITE sip:]]><strong>$(service)</strong><![CDATA[@]]><strong>$(param_ip)</strong><![CDATA[ SIP/2.0
      Via: SIP/2.0/UDP north.east.isi.edu
      From: Mark Handley <sip:mjh@isi.edu>
      To: Eve Schooler <sip:schooler@caltech.edu>
      Call-ID: 2963313058@north.east.isi.edu
      CSeq: 1 INVITE
      Subject: SIP will be discussed, too
      Content-Type: application/sdp
      Content-Length: 187 ]] >
</message>
      ]]></source>
        
        (See "<a href="sip.html#first_try_param">SIP first try</a>" for a commented example)
        </p>
      </section>
      <section id="scenario_ref">
        <title>Scenario reference</title>
        <p>This section is the reference for Seagull scenarios.</p>
        <p>This table is the list of commands that can be used in 
        <a href="#config_scenario">scenarios</a>
        with their attributes.</p>
        <anchor id="ref_scenario_commands"/>
        <table>
          <caption>List of scenario commands with their attributes</caption>
          <tr>
            <th>Command</th>
            <th>Attribute(s)</th>
            <th>Description</th>
            <th>Example</th>
          </tr>
          <tr>
            <th>
              <anchor id="cmd_send"/>
              <strong>&lt;send&gt;</strong>
            </th>
            <th></th>
            <th>
              <strong>Send a message on a transport channel</strong>
            </th>
            <th></th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>channel</td>
            <td>Refers to "transport-channel" entities, as defined in the  
            <a href="#config_generic">generic configuration file</a>.
            </td>
            <td>
              <code>channel="trans-ip-v4"</code>: Use trans-ip-v4 channel.</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>label</td>
            <td>Optional. Refers to correlation "command" entities, as defined in the  
            <a href="#ref_correlation">correlation</a> section.
            </td>
            <td>
              <code>label="command-1"</code>: refers to the "command-1".</td>
          </tr>
          <tr>
            <th>
              <anchor id="cmd_receive"/>
              <strong>&lt;receive&gt;</strong>
            </th>
            <th></th>
            <th>
              <strong>Receive a message on a transport channel</strong>
            </th>
            <th></th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>channel</td>
            <td>Refers to "transport-channel" entities, as defined in the  
            <a href="#config_generic">generic configuration file</a>.
            </td>
            <td>
              <code>channel="trans-ip-v4"</code>: Use trans-ip-v4 channel.</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>label</td>
            <td>Optional. Refers to correlation "command" entities, as defined in the  
            <a href="#ref_correlation">correlation</a> section.
            </td>
            <td>
              <code>label="command-1"</code>: refers to the "command-1".</td>
          </tr>
          <tr>
            <th>
              <anchor id="cmd_wait"/>
              <strong>&lt;wait-ms&gt;</strong>
            </th>
            <th></th>
            <th>
              <strong>Wait a number of milliseconds before continuing</strong>
            </th>
            <th>&nbsp;</th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>value</td>
            <td>Number of milliseconds to wait for.</td>
            <td>
              <code><![CDATA[<wait-ms value="2000"></wait-ms>]]></code>: wait
            for 2 seconds</td>
          </tr>
          <tr>
            <th>
              <anchor id="counterdef"/>
              <strong>&lt;counterdef&gt;</strong>
            </th>
            <th></th>
            <th>
              <strong>Define a counter</strong>
            </th>
            <th>&nbsp;</th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>name</td>
            <td>Name of the counter</td>
            <td>
              <code><![CDATA[name="client-id-counter"]]></code>
            </td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>init</td>
            <td>Initial value of the counter</td>
            <td>
              <code><![CDATA[init="1"]]></code>
            </td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>min</td>
            <td>Optional. Minimal value of the counter. <br/>
             (Default value is 0)</td>
            <td>
              <code><![CDATA[min="0"]]></code>
            </td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>max</td>
            <td>Optional. Maximal value of the counter. The interpretation of the value of this attribute depends on the platform and 
            corresponds to an Unsigned long defined in the file "limit.h". <br/>
            If "max" is defined, when the "max" value is reached, the counter  
            is re-initialized to the value defined by the "behaviour" attribute.</td>
            <td>
              <code><![CDATA[max="100"]]></code>
            </td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>behaviour</td>
            <td>Optional. Possible values of this attribute are: <br/> 
            "init"    : when the "max" value is reached, the counter is re-initialized to the "init" value,<br/>
            "min"     : when the "max" value is reached, the counter is re-initialized to the "min" value,<br/>
            "no_reset": when the "max" value is reached, the counter is not re-initialized and stays at the "max" value. <br/>
            (Default value is "min") </td>
            <td>
              <code><![CDATA[behaviour="init"]]></code>
            </td>
          </tr>
	  <!-- WHAT IS THE PURPOSE OF END COMMAND?
          <tr>
            <th>
              <anchor id="cmd_end"/>
              <strong>&lt;end&gt;</strong>
            </th>
            <th>-</th>
            <th>-</th>
            <th>-</th>
          </tr>
          -->
        </table>
        <p class="pageBreakBefore">This table is the list of <a href="#scen_cmds">actions</a> that can be used in 
        &lt;send&gt; or &lt;receive&gt; commands.</p>
        <anchor id="ref_actions"/>
        <table>
          <caption>List of actions</caption>
          <tr>
            <th>Action</th>
            <th>Attribute(s)</th>
            <th>Description</th>
            <th>Example</th>
          </tr>
          <tr>
            <th>
              <anchor id="action_open"/>
              <strong>&lt;open&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>'open' action opens an instance of the transport channel. This can
            be used for example to open a new TCP socket for each call. Don't
            forget to use 'close' action at the end of the scenario.</th>
            <th>
             <code><![CDATA[<open args="mode=client;dest=10.10.11.157:8080"></open>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>args</td>
            <td>Argument relevant to the transport channel used</td>
            <td>
              mode=client;dest=10.10.11.157:8080
            </td>
          </tr>
          <tr>
            <th>
              <anchor id="action_close"/>
              <strong>&lt;close&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>Close a transport channel</th>
            <th>
              <code><![CDATA[<close name="channel-1"></close>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>name</td>
            <td>Name of the channel to be closed.</td>
            <td>channel-1</td>
          </tr>
          <tr>
            <th>
              <anchor id="action_store"/>
              <strong>&lt;store&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>Store the value of a protocol entity in a call variable</th>
            <th>
              <code><![CDATA[<store name="sid" entity="Session-Id"> </store>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>name</td>
            <td>Name of the call variable where to store the protocol entity.</td>
            <td>sid</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>entity</td>
            <td>Name of the protocol entity to store. It can be any protocol entity (body or header).</td>
            <td>Session-Id</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>instance</td>
            <td>Instance identifier of the component to be stored.</td>
            <td>instance="InitialDP-data"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>sub-entity</td>
            <td>Identifier of the parameter of the component to be stored.</td>
            <td>sub-entity="operation-code"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>begin</td>
            <td>Position from which we start to get the data. Be careful, the 
	    count for the position starts at zero. Example for the second position:</td>
            <td>begin="1"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>end</td>
            <td>Position at which we stop to get the data. Be careful, the 
	    count for the position starts at zero and the last piece of injected data 
	    is at the end position minus one.</td>
            <td>end="9"</td>
          </tr>
          <tr>
            <th>
              <anchor id="action_restore"/>
              <strong>&lt;restore&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>Restore the value of a call variable in a protocol entity (reverse operation of "store")</th>
            <th>
              <code><![CDATA[<restore name="sid" entity="Session-Id"></restore>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>name</td>
            <td>Name of the call variable where to restore from.</td>
            <td>sid</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>entity</td>
            <td>Name of the protocol entity to restore to.</td>
            <td>Session-Id</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>instance</td>
            <td>Instance identifier of the component to be restored.</td>
            <td>instance="InitialDP-data"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>sub-entity</td>
            <td>Identifier of the parameter of the component to be restored.</td>
            <td>sub-entity="operation-code"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>begin</td>
            <td>Position at which we start to inject the data. Be careful, the 
	    count for the position starts at zero. Example for the second position:</td>
            <td>begin="1"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>end</td>
            <td>Position at which we stop to inject the data. Be careful, the 
	    count for the position starts at zero and the last piece of injected data 
	    is at the end position minus one.</td>
            <td>end="9"</td>
          </tr>
          <tr>
            <th>
              <anchor id="action_start-timer"/>
              <strong>&lt;start-timer&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>Start the timer for <a href="#stats_responsetime">response time statistics</a>
            </th>
            <th>-</th>
          </tr>
          <tr>
            <th>
              <anchor id="action_stop-timer"/>
              <strong>&lt;stop-timer&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>Stop the timer for <a href="#stats_responsetime">response time statistics</a>
            </th>
            <th>-</th>
          </tr>
          <tr>
            <th>
              <anchor id="action_set-value"/>
              <strong>&lt;set-value&gt;</strong>
            </th>
            <th>-</th>
            <th>Set the value of a protocol entity given a format</th>
            <th>
              <code><![CDATA[<set-value name="Session-Id" format=".;1096298391;$(session-counter)"> </set-value>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>name</td>
            <td>Name of the protocol entity to set</td>
            <td>"Session-Id" set the value of Session-Id parameter</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>format</td>
            <td>The format is a string that can contain call variables (identified by $(varname)).<br/>
                If associated to the "method" attribute, it is used to pass parameters to the method (refer to <a href="#Authentication">Authentication</a> 
                for further details). </td>
            <td>".;1096298391;$(session-counter)": fixed string with a variable part (value of "session-counter" call variable)</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>method</td>
            <td>Optional. The method refers to an "external-method" of the dictionary. It defines the function to encode the value.</td>
            <td>"authentication"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>message_part</td>
            <td>Optional and only if the "method" attribute is used. The message_part defines the part of the message that is used by the method to encode the value.
            Allowed values are :<br/>
             "" (default value)<br/>
             "body"<br/>
             "header"<br/>
             "all" </td>
            <td>""</td>
          </tr>
          <tr>
            <th>
              <anchor id="action_set-bit"/>
              <strong>&lt;set-bit&gt;</strong>
            </th>
            <th>-</th>
            <th>Set the value of a bit in a call variable (memory zone). This is only available for variables of number or string type.
                Value can only be 0 or 1. The position starts at 0 (second position is 1).</th>
            <th>
              <code><![CDATA[<set-bit name="call-variable" entity="field-from-dictionary"
                              instance="InitialDP-data" sub-entity="operation-code"
                              position="x" value="y"></set-bit>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>name</td>
            <td>Name of the call variable where to store the protocol entity.</td>
            <td>sid</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>entity</td>
            <td>Name of the stored protocol entity. Needed to determine the type of the call variable.</td>
            <td>Session-Id</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>instance</td>
            <td>Instance identifier of the component to be stored.</td>
            <td>instance="InitialDP-data"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>sub-entity</td>
            <td>Identifier of the parameter of the component to be stored.</td>
            <td>sub-entity="operation-code"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>position</td>
            <td>Position of the bit to be changed. Position starts at 0. Example for the second position:</td>
            <td>position="1"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>value</td>
            <td>New value of the bit. Admitted values are 0 or 1.</td>
            <td>value="0"</td>
          </tr>
          <tr>
            <th>
              <anchor id="action_set-value-bit"/>
              <strong>&lt;set-value-bit&gt;</strong>
            </th>
            <th>-</th>
            <th>Set the value of a bit in a field of a message. This is only available for variables of number or string type.
                Value can only be 0 or 1. The position starts at 0 (second position is 1).</th>
            <th>
              <code><![CDATA[<set-value-bit entity="field-from-dictionary"
                              instance="InitialDP-data" sub-entity="operation-code"
                              position="x" value="y"> </set-value-bit>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>entity</td>
            <td>Name of the stored protocol entity. Needed to determine the type of the call variable.</td>
            <td>Session-Id</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>instance</td>
            <td>Instance identifier of the stored component.</td>
            <td>instance="InitialDP-data"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>sub-entity</td>
            <td>Identifier of the parameter of the stored component.</td>
            <td>sub-entity="operation-code"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>position</td>
            <td>Position of the bit to be changed. Position starts at 0. Example for the second position:</td>
            <td>position="1"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>value</td>
            <td>New value of the bit. Admitted values are 0 or 1.</td>
            <td>value="0"</td>
          </tr>
          <tr>
            <th>
              <anchor id="action_setfield"/>
              <strong>&lt;setfield&gt;</strong>
            </th>
            <th>-</th>
            <th>Set the value of a field of a message. This is only available for  
                external (header and body fields) and binary (header fields only) protocols.</th>
            <th>
              <code><![CDATA[<setfield name="field-from-dictionary" value="XX"></setfield>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>name</td>
            <td>Name of the protocol field.</td>
            <td>name="field-from-dictionary"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>value</td>
            <td>Value of the field.</td>
            <td>value="XX"</td>
          </tr>
          <tr>
            <th>
              <anchor id="action_inc-counter"/>
              <strong>&lt;inc-counter&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>Increment a global counter</th>
            <th>
              <code><![CDATA[<inc-counter name="HbH-counter"> </inc-counter>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>name</td>
            <td>Name of the global counter to increment</td>
            <td>"HbH-counter" increment the value of HbH-counter by 1</td>
          </tr>
          <tr>
            <th>
              <anchor id="action_inc-var"/>
              <strong>&lt;inc-var&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>Increment a variable of a call</th>
            <th>
              <code><![CDATA[<inc-var name="INVOKE-ID"> </inc-var>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>name</td>
            <td>Name of the call variable to increment</td>
            <td>"INVOKE-ID" increment the value of INVOKE-ID by 1</td>
          </tr>
          <tr>
            <th>
              <anchor id="check-presence"/>
              <strong>&lt;check-presence&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>
              <a href="#control">Check</a> that a protocol entity is present</th>
            <th>
              <code><![CDATA[<check-presence name="[FIELD_NAME]" behaviour="error"></check-presence>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>name</td>
            <td>Name of the protocol entity to check</td>
            <td>name="bar" for bar field</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>behaviour</td>
            <td>Behaviour to adopt in case the protocol entity is missing. Can be "error" or "warning"</td>
            <td>behaviour="error"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>instance</td>
            <td>Instance identifier of the component to be checked.</td>
            <td>instance="InitialDP-data"</td>
          </tr>
		  <tr>
            <td>&nbsp;</td>
            <td>occurrence</td>
            <td>Optional (default is 1).Specifies the position of the field,in case of multiple occurrences (used with grouped AVPs in diameter).</td>
            <td>occurrence="1"</td>
          </tr>
          <tr>
            <th>
              <anchor id="check-value"/>
              <strong>&lt;check-value&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>
              <a href="#control">Check</a> the value of a header field or of a 
	      message paramater</th>
            <th>
              <code><![CDATA[<check-value name="[FIELD_NAME]" behaviour="error"></check-value>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>name</td>
            <td>Name of the protocol entity to check</td>
            <td>name="bar" for bar field</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>behaviour</td>
            <td>Behaviour to adopt in case the value is not the expected one. 
	    Can be "error" or "warning"</td>
            <td>behaviour="error"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>instance</td>
            <td>Instance identifier of the component to be checked.</td>
            <td>instance="InitialDP-data"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>sub-entity</td>
            <td>Identifier of parameter of the component to be checked.</td>
            <td>sub-entity="operation-code"</td>
          </tr>
		  <tr>
            <td>&nbsp;</td>
            <td>branch_on</td>
            <td>Specifies the received message,on which the scenario execution is branched,to point either ahead,or back in the scenario.</td>
            <td>branch_on="180"</td>
          </tr>
	  	  <tr>
            <td>&nbsp;</td>
            <td>look_ahead</td>
            <td>(default 1)Specifies the number of jumps in traffic section of the scenario ahead.</td>
            <td>look_ahead="2"</td>
          </tr>
	  	  <tr>
            <td>&nbsp;</td>
            <td>look_back</td>
            <td>(default 0).Specifies the number of jumps in traffic section of the scenario backwards.</td>
            <td>look_back="1"</td>
          </tr>
          <tr>
            <th>
              <anchor id="check-order"/>
              <strong>&lt;check-order&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>
              <a href="#control">Check</a> the type of message received at a specified position 
	      </th>
            <th>
              <code><![CDATA[<check-order name="[FIELD_NAME]" behaviour="error" 
	      position="[X]"> </check-order>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>name</td>
            <td>Name of the message to check</td>
            <td>name="bar" for bar message</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>behaviour</td>
            <td>Behaviour to adopt in case the position is not the one expected. 
	    Can be "error" or "warning"</td>
            <td>behaviour="error"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>position</td>
            <td>Position at which the message is awaited. Be careful: positions start at 0.</td>
            <td>position="0"</td>
          </tr>
          <tr>
            <th>
              <anchor id="restore-from-external"/>
              <strong>&lt;restore-from-external&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>
              Modify the value of a field with data coming from a file</th>
            <th>
              <code><![CDATA[<restore-from-external field="1" entity="Volume_requested"> </restore-from-external>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>field</td>
            <td>The number of the data field used, in the data file</td>
            <td>field="0" for the first field</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>entity</td>
            <td>The field of the message to which is assigned the new value</td>
            <td>entity="Volume_requested"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>sub-entity</td>
            <td>Identifier of component parameter in which we insert some data.</td>
            <td>sub-entity="operation-data"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>instance</td>
            <td>Instance identifier of the component to be checked.</td>
            <td>instance="InitialDP-data"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>begin</td>
            <td>Position at which we start to inject the data. Be careful, the 
	    count for the positions start at zero. Example for the second position:</td>
            <td>begin="1"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>end</td>
            <td>Position at which we stop to inject the data. Be careful, the 
	    count for the positions start at zero, and the last piece of data 
	    injected is at end position minus one.</td>
            <td>end="9"</td>
          </tr>
		  <tr>
            <td>&nbsp;</td>
            <td>occurrence</td>
            <td>Optional (default is 1).Specifies the position of the field,in case of multiple occurrences (used with grouped AVPs in diameter).</td>
            <td>occurrence="1"</td>
          </tr>
          <tr>
            <th>
              <anchor id="restore-from-external-variable"/>
              <strong>&lt;restore-from-external&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>
              Restore a value with data coming from a file into a call variable</th>
            <th>
              <code><![CDATA[<restore-from-external name="call_variable" field="1"> </restore-from-external>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>name</td>
            <td>The field of the message to which is assigned the new value</td>
            <td>entity="Volume_requested"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>field</td>
            <td>The number of the data field used, in the data file</td>
            <td>field="0" for the first field</td>
          </tr>
          <tr>
            <th>
              <anchor id="set-new-session-id"/>
              <strong>&lt;set-new-session-id&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>
              Change the value by which a session (scenario execution) 
              is identified. This allows scenarios to be executed with multiple
              session-ids in one scenario. See <a href="h248.html">H248</a> for an example.</th>
            <th>
              <code><![CDATA[<set-new-session-id name="TID" entity="transaction-id"></set-new-session-id>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>name</td>
            <td>Value that was used to identify the session (can be a variable that was stored or a counter).</td>
            <td>name="TID"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>entity</td>
            <td>New value to use to identify the session (like the value of a protocol field)</td>
            <td>name="transaction-id"</td>
          </tr>
          <tr>
            <th>
              <anchor id="transport-option"/>
              <strong>&lt;transport-option&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>
              Change the mode from no secure to secure transport during execution.
				  A "wait-ms" (with value="1000" at least) command is needed after this action 
              to let systems synchronize the secure mode.</th>
            <th>
              <code><![CDATA[<transport-option channel="channel-1" value="secure-mode"></transport-option>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>channel</td>
            <td>Value that was used to identify the channel.</td>
            <td>channel="channel-1"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>value</td>
            <td>"secure-mode" indicates that the mode will change to secure (the only agreed value). </td>
            <td>value="secure-mode"</td>
          </tr>
          <tr>
            <th>
              <anchor id="insert-in-map"/>
              <strong>&lt;insert-in-map&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>
              Specific to "Correlation" feature. It inserts in the list of known session-ids for the given "channel" the value of the "entity" (that is defined in the dictionary).</th>
            <th>
              <code><![CDATA[<insert-in-map channel="channel-1" entity="HbH-id"></insert-in-map>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>channel</td>
            <td>Value that was used to identify the channel.</td>
            <td>channel="channel-1"</td>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>entity</td>
            <td>Add the value of the "entity" to te map of known session-ids.</td>
          </tr>
          <tr>
            <th>
              <anchor id="log-user"/>
              <strong>&lt;log&gt;</strong>
            </th>
            <th>&nbsp;</th>
            <th>
              Add a user comments in the log file (with the possibility to dump variables, 
              stored with the "store" action, and counters). To activate user logs, the "U" 
              log level is needed in the command line.</th>
            <th>
              <code><![CDATA[<log format="User log, call-id= $(SID)"></log>]]></code>
            </th>
          </tr>
          <tr>
            <td>&nbsp;</td>
            <td>format</td>
            <td>User comment to be added to the log file.</td>
            <td>format="User log, call-id= $(SID)"</td>
          </tr>
        </table>
      </section>
      <!--
      <section id="config_dict_ref">
        <title>Protocol Dictionary reference</title>
        <p></p>
      </section>  -->
      <section id="cli_help">
        <title>Command line arguments</title>
        <source><![CDATA[$ seagull -help
seagull Command syntax
 -conf <configuration file name>
 -scen <scenario file name>
 -dico <protocol dictionary file name> can be used more than once
[ -log <logging file name> ]
[ -llevel <logging level mask> ] levels:
          M: msg,     B: buffer,   E: error,
          W: warning, N: no error, T: traffic error,
          V: Verdict, U: User,     A: all.      Default E
[ -help  ] display syntax command line
[ -bg  ] background mode
[ -notimelog  ] no time stamp on the log (default time stamp)
[ -msgcheck  ] check the field of the messages received (default no check)]]></source>
      </section>
      <section id="cli_return_code">
        <title>Seagull return code</title>
        <p>Seagull returns a global status of the calls through the return code:</p>
        <ul>
          <li>	0 : ok, seagull did not meet any problems and all calls finished well.</li>
          <li>	-1 : fatal error, seagull met a fatal error and stopped.</li>
          <li>	>1 : error, at least, one call failed ("Ignored" calls are not considered as failed; the init section is concidered as a independant call).</li>
        </ul>
      </section>
    </section>
    <section>
      <title>Miscellaneous tools</title>
      <p>When working with Seagull, there are some useful and complementary tools:</p>
      <ul>
        <li><a href="http://www.wireshark.org/">Wireshark</a>: formerly known as "Ethereal", Wireshark
        is a protocol decoder. It will most likely decode all the protocols supported by Seagull.</li>
        <li><a href="http://laurent.riesterer.free.fr/regexp/">Visual REGEXP</a>: this invaluable
        tool can be used to debug regular expressions (widely used in Seagull!).</li>
      </ul>
    </section>

  </body>
</document>
